#####################################################
# all ecs ip/hostname fields
# related.ip, client.nat.ip, server.nat.ip, source.nat.ip, destination.nat.ip
# 
# client.ip, client.address
# destination.ip, destination.address
# server.ip, server.address
# source.ip, source.address
# host.ip, host.hostname
# observer.ip, observer.hostname
# 
# not touching related.ip as it would be duplicated
# and .nat.ip fields do not have corresponding name fields
# 
# for all others
# if .ip field exists and .hostname/.address does not
# then copy the .ip to .hostname/.address and lookup for name
# and replace the .hostname value with the found name
# 
# don't want to retry coz of high volume. Also same IPs would be hit in next logs and maybe cached
#####################################################
filter { 
  if "disable_dns_enrichment" in [tags] or "disable_lookups" in [tags] or "disable_enrichments" in [tags] {
    mutate {
      remove_tag => ["disable_dns_enrichment"]
    }
  } else {
    if [host.hostname] =~ "^\d+\.\d+\.\d+\.\d+$" and ![host.ip] {
      mutate {
        copy => { "host.hostname" =>  "host.ip" }
        remove_field => [ "host.hostname" ]
      }
    }
    ### DNS lookup
    if [host.ip] and ![host.hostname] {
      ### Exclude loopback address
      if [host.ip] != "^127\.\d+\.\d+\.\d+$" {
        mutate {
          add_field => { "host.hostname" => "%{host.ip}" }
        }
      ### Private vs Public
      } else if [host.ip] =~ "^100\.(64|[7-9][0-9]|1[0-1][0-9]|12[0-7])\.\d+\.\d+$" or [host.ip] =~ "^10\.\d+\.\d+\.\d+$" or [host.ip] =~ "^192.168\.\d+\.\d+$" or [host.ip] =~ "^172\.([1][6-9]|[2][0-9]|[3][0-1])\.\d+\.\d+$" {
        # PRIVATE_DNS
        dns {
          nameserver => {
            address => ["10.2.104.11", "10.2.204.11"] # change to PRIVATE_DNS
          }
          reverse => ["host.hostname"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_host.hostname"]
        }
      } else {
        # PUBLIC_DNS
        dns {
          nameserver => {
            address => ["10.25.106.222", "10.47.193.222"] # change to PUBLIC_DNS
          }
          reverse => ["host.hostname"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_host.hostname"]
        }
      }
      if ![host.domain] and "_dns_success_host.hostname" in [tags] {
        dissect {
          mapping => {
            "host.hostname" => "%{?host_name}.%{host.domain}"
          }
        }
        mutate {
          remove_tag => ["_dns_success_host.hostname"]
        }
      }
    }
    if [client.address] =~ "^\d+\.\d+\.\d+\.\d+$" and ![client.ip] {
      mutate {
        copy => { "client.address" =>  "client.ip" }
        remove_field => [ "client.address" ]
      }
    }
    ### DNS lookup
    if [client.ip] and ![client.address] {
      ### Exclude loopback address
      if [client.ip] != "^127\.\d+\.\d+\.\d+$" {
        mutate {
          add_field => { "client.address" => "%{client.ip}" }
        }
      ### Private vs Public
      } else if [client.ip] =~ "^100\.(64|[7-9][0-9]|1[0-1][0-9]|12[0-7])\.\d+\.\d+$" or [client.ip] =~ "^10\.\d+\.\d+\.\d+$" or [client.ip] =~ "^192.168\.\d+\.\d+$" or [client.ip] =~ "^172\.([1][6-9]|[2][0-9]|[3][0-1])\.\d+\.\d+$" {
        # PRIVATE_DNS
        dns {
          nameserver => {
            address => ["10.2.104.11", "10.2.204.11"] # change to PRIVATE_DNS
          }
          reverse => ["client.address"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_client.address"]
        }
      } else {
        # PUBLIC_DNS
        dns {
          nameserver => {
            address => ["10.25.106.222", "10.47.193.222"] # change to PUBLIC_DNS
          }
          reverse => ["client.address"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_client.address"]
        }
      }
      if ![client.domain] and "_dns_success_client.address" in [tags] {
        dissect {
          mapping => {
            "client.address" => "%{?host_name}.%{client.domain}"
          }
        }
        mutate {
          remove_tag => ["_dns_success_client.address"]
        }
      }
    }
    if [destination.address] =~ "^\d+\.\d+\.\d+\.\d+$" and ![destination.ip] {
      mutate {
        copy => { "destination.address" =>  "destination.ip" }
        remove_field => [ "destination.address" ]
      }
    }
    ### DNS lookup
    if [destination.ip] and ![destination.address] {
      ### Exclude loopback address
      if [destination.ip] != "^127\.\d+\.\d+\.\d+$" {
        mutate {
          add_field => { "destination.address" => "%{destination.ip}" }
        }
      ### Private vs Public
      } else if [destination.ip] =~ "^100\.(64|[7-9][0-9]|1[0-1][0-9]|12[0-7])\.\d+\.\d+$" or [destination.ip] =~ "^10\.\d+\.\d+\.\d+$" or [destination.ip] =~ "^192.168\.\d+\.\d+$" or [destination.ip] =~ "^172\.([1][6-9]|[2][0-9]|[3][0-1])\.\d+\.\d+$" {
        # PRIVATE_DNS
        dns {
          nameserver => {
            address => ["10.2.104.11", "10.2.204.11"] # change to PRIVATE_DNS
          }
          reverse => ["destination.address"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_destination.address"]
        }
      } else {
        # PUBLIC_DNS
        dns {
          nameserver => {
            address => ["10.25.106.222", "10.47.193.222"] # change to PUBLIC_DNS
          }
          reverse => ["destination.address"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_destination.address"]
        }
      }
      if ![destination.domain] and "_dns_success_destination.address" in [tags] {
        dissect {
          mapping => {
            "destination.address" => "%{?host_name}.%{destination.domain}"
          }
        }
        mutate {
          remove_tag => ["_dns_success_destination.address"]
        }
      }
    }
    if [server.address] =~ "^\d+\.\d+\.\d+\.\d+$" and ![server.ip] {
      mutate {
        copy => { "server.address" =>  "server.ip" }
        remove_field => [ "server.address" ]
      }
    }
    ### DNS lookup
    if [server.ip] and ![server.address] {
      ### Exclude loopback address
      if [server.ip] != "^127\.\d+\.\d+\.\d+$" {
        mutate {
          add_field => { "server.address" => "%{server.ip}" }
        }
      ### Private vs Public
      } else if [server.ip] =~ "^100\.(64|[7-9][0-9]|1[0-1][0-9]|12[0-7])\.\d+\.\d+$" or [server.ip] =~ "^10\.\d+\.\d+\.\d+$" or [server.ip] =~ "^192.168\.\d+\.\d+$" or [server.ip] =~ "^172\.([1][6-9]|[2][0-9]|[3][0-1])\.\d+\.\d+$" {
        # PRIVATE_DNS
        dns {
          nameserver => {
            address => ["10.2.104.11", "10.2.204.11"] # change to PRIVATE_DNS
          }
          reverse => ["server.address"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_server.address"]
        }
      } else {
        # PUBLIC_DNS
        dns {
          nameserver => {
            address => ["10.25.106.222", "10.47.193.222"] # change to PUBLIC_DNS
          }
          reverse => ["server.address"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_server.address"]
        }
      }
      if ![server.domain] and "_dns_success_server.address" in [tags] {
        dissect {
          mapping => {
            "server.address" => "%{?host_name}.%{server.domain}"
          }
        }
        mutate {
          remove_tag => ["_dns_success_server.address"]
        }
      }
    }
    if [source.address] =~ "^\d+\.\d+\.\d+\.\d+$" and ![source.ip] {
      mutate {
        copy => { "source.address" =>  "source.ip" }
        remove_field => [ "source.address" ]
      }
    }
    ### DNS lookup
    if [source.ip] and ![source.address] {
      ### Exclude loopback address
      if [source.ip] != "^127\.\d+\.\d+\.\d+$" {
        mutate {
          add_field => { "source.address" => "%{source.ip}" }
        }
      ### Private vs Public
      } else if [source.ip] =~ "^100\.(64|[7-9][0-9]|1[0-1][0-9]|12[0-7])\.\d+\.\d+$" or [source.ip] =~ "^10\.\d+\.\d+\.\d+$" or [source.ip] =~ "^192.168\.\d+\.\d+$" or [source.ip] =~ "^172\.([1][6-9]|[2][0-9]|[3][0-1])\.\d+\.\d+$" {
        # PRIVATE_DNS
        dns {
          namesource => {
            address => ["10.2.104.11", "10.2.204.11"] # change to PRIVATE_DNS
          }
          reverse => ["source.address"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_source.address"]
        }
      } else {
        # PUBLIC_DNS
        dns {
          namesource => {
            address => ["10.25.106.222", "10.47.193.222"] # change to PUBLIC_DNS
          }
          reverse => ["source.address"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
          add_tag => ["_dns_success_source.address"]
        }
      }
      if ![source.domain] and "_dns_success_source.address" in [tags] {
        dissect {
          mapping => {
            "source.address" => "%{?host_name}.%{source.domain}"
          }
        }
        mutate {
          remove_tag => ["_dns_success_source.address"]
        }
      }
    }
    if [observer.hostname] =~ "^\d+\.\d+\.\d+\.\d+$" and ![observer.ip] {
      mutate {
        copy => { "observer.hostname" =>  "observer.ip" }
        remove_field => [ "observer.hostname" ]
      }
    }
    ### DNS lookup
    if [observer.ip] and ![observer.hostname] {
      ### Exclude loopback address
      if [observer.ip] != "^127\.\d+\.\d+\.\d+$" {
        mutate {
          add_field => { "observer.hostname" => "%{observer.ip}" }
        }
      ### Private vs Public
      } else if [observer.ip] =~ "^100\.(64|[7-9][0-9]|1[0-1][0-9]|12[0-7])\.\d+\.\d+$" or [observer.ip] =~ "^10\.\d+\.\d+\.\d+$" or [observer.ip] =~ "^192.168\.\d+\.\d+$" or [observer.ip] =~ "^172\.([1][6-9]|[2][0-9]|[3][0-1])\.\d+\.\d+$" {
        # PRIVATE_DNS
        dns {
          namesource => {
            address => ["10.2.104.11", "10.2.204.11"] # change to PRIVATE_DNS
          }
          reverse => ["observer.hostname"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
        }
      } else {
        # PUBLIC_DNS
        dns {
          namesource => {
            address => ["10.25.106.222", "10.47.193.222"] # change to PUBLIC_DNS
          }
          reverse => ["observer.hostname"]
          action => "replace"
          max_retries => 0
          hit_cache_size => 500000
          hit_cache_ttl => 3600
          failed_cache_size => 500000
          failed_cache_ttl => 3600
        }
      }
    }
  }
}