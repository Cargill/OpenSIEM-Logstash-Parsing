##### mapping logs with MISP memcache
filter {
  if "disable_lookup_iana_protocol_enrichment" in [tags] or "disable_enrichments" in [tags] {
    mutate {
      remove_tag => ["disable_lookup_iana_protocol_enrichment"]
    }
  } else {
    if [process.hash.md5] and [process.hash.md5] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "process.hash.md5"
        get => {
          "%{process.hash.md5}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_process.hash.md5" ]
      }
    }
    if "memcached_get_success_process.hash.md5" in [tags] {
      kv {
      source => "memcache_value"
      target => "mc"
      }
      mutate {
        update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
        update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
        update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
        update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
        update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
        update => { "[mc][threat.list.category]" => "threat.list.category" }
        update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
        update => { "[mc][threat.list.comment]" => "threat.list.comment" }
        update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
        update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
        update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
        update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
        update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
        remove_field => ["memcache_value", "mc" ]
      }
    }
    if [process.parent.hash.md5] and [process.parent.hash.md5] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "process.parent.hash.md5"
        get => {
          "%{process.parent.hash.md5}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_process.parent.hash.md5" ]
      }
      if "memcached_get_success_process.parent.hash.md5" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [file.hash.md5] and [file.hash.md5] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.hash.md5"
        get => {
          "%{file.hash.md5}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.hash.md5" ]
      }
      if "memcached_get_success_file.hash.md5" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [file.hash.sha1] and [file.hash.sha1] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.hash.sha1"
        get => {
          "%{file.hash.sha1}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.hash.sha1" ]
      }
      if "memcached_get_success_file.hash.sha1" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [file.hash.sha256] and [file.hash.sha256] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.hash.sha256"
        get => {
          "%{file.hash.sha256}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.hash.sha256" ]
      }
      if "memcached_get_success_file.hash.sha256" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [file.hash.sha512] and [file.hash.sha512] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.hash.sha512"
        get => {
          "%{file.hash.sha512}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.hash.sha512" ]
      }
      if "memcached_get_success_file.hash.sha512" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [file.name] and [file.name] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.name"
        get => {
          "%{file.name}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.name" ]
      }
      if "memcached_get_success_file.name" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if ([file.name] and [file.name] != "" ) and ([file.hash.md5] and [file.hash.md5] != "" )  {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.name_file.hash.md5"
        get => {
          "%{file.name}|%{file.hash.md5}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.name_file.hash.md5" ]
      }
      if "memcached_get_success_file.name_file.hash.md5" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if ([file.name] and [file.name] != "" ) and ([file.name_hash.sha1] and [file.name_hash.sha1] != "" )  {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.name_file.hash.sha1"
        get => {
          "%{file.name}|%{file.name_hash.sha1}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.name_file.hash.sha1" ]
      }
      if "memcached_get_success_file.name_file.hash.sha1" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if ([file.name] and [file.name] != "" ) and ([file.hash.sha256] and [file.hash.sha256] != "" )  {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.name_file.hash.sha256"
        get => {
          "%{file.name}|%{file.hash.sha256}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_" ]
      }
      if "memcached_get_success_file.name_file.hash.sha256" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if ([file.name] and [file.name] != "" ) and ([file.hash.sha512] and [file.hash.sha512] != "" )  {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.name_file.hash.sha512"
        get => {
          "%{file.name}|%{file.hash.sha512}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.name_file.hash.sha512" ]
      }
      if "memcached_get_success_file.name_file.hash.sha512" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [source.ip] and [source.ip] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "source.ip"
        get => {
          "%{source.ip}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_source.ip" ]
      }
      if "memcached_get_success_source.ip" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [destination.ip] and [destination.ip] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "destination.ip"
        get => {
          "%{destination.ip}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_destination.ip" ]
      }
      if "memcached_get_success_destination.ip" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [host.name] and [host.name] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "host.name"
        get => {
          "%{host.name}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_host.name" ]
      }
      if "memcached_get_success_host.name" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [url.domain] and [url.domain] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "url.domain"
        get => {
          "%{url.domain}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_url.domain" ]
      }
      if "memcached_get_success_url.domain" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if ([url.domain] and [url.domain] != "" ) and ([destination.ip] and [destination.ip] and  != "" ) {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "url.domain_destination.ip"
        get => {
          "%{url.domain}|%{destination.ip}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_url.domain_destination.ip" ]
      }
      if "memcached_get_success_url.domain_destination.ip" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [url.full] and [url.full] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "url.full"
        get => {
          "%{url.full}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_url.full" ]
      }
      if "memcached_get_success_url.full" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [http.request.method] and [http.request.method] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "http.request.method"
        get => {
          "%{http.request.method}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_http.request.method" ]
      }
      if "memcached_get_success_http.request.method" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [user_agent.original] and [user_agent.original]  != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "user_agent.original"
        get => {
          "%{user_agent.original}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_user_agent.original" ]
      }
      if "memcached_get_success_user_agent.original" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [tls.server.hash.md5] and [tls.server.hash.md5] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "tls.server.hash.md5"
        get => {
          "%{tls.server.hash.md5}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_tls.server.hash.md5" ]
      }
      if "memcached_get_success_tls.server.hash.md5" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [registry.key] and [registry.key]  != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "registry.key"
        get => {
          "%{registry.key}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_registry.key" ]
      }
      if "memcached_get_success_registry.key" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if ( [registry.key] and [registry.key] != "" ) and ( [registry.value] and [registry.value] and  != "" ) {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "registry.key_registry.value"
        get => {
          "%{registry.key}|%{registry.value}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_registry.key_registry.value" ]
      }
      if "memcached_get_success_registry.key_registry.value" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [source.as.organization.name] and [source.as.organization.name] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "source.as.organization.name"
        get => {
          "%{source.as.organization.name}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_source.as.organization.name" ]
      }
      if "memcached_get_success_source.as.organization.name" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [rule.description] and [rule.description] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "rule.description"
        get => {
          "%{rule.description}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_rule.description" ]
      }
      if "memcached_get_success_rule.description" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    # if [process.hash.md5] and [process.hash.md5] != "" {
    #   memcached {
    #     hosts => ["VAR_MEMCACHED_HOST"]
    #     namespace => "process.hash.md5"
    #     get => {
    #       "%{process.hash.md5}" => "[memcache_value]"
    #     }
    #     ttl => 60
    #     add_tag => [ "memcached_get_success_process.hash.md5" ]
    #   }
    #   if "memcached_get_success_process.hash.md5" in [tags] {
    #     kv {
    #     source => "memcache_value"
    #     target => "mc"
    #     }
    #     mutate {
    #       update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
    #       update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
    #       update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
    #       update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
    #       update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
    #       update => { "[mc][threat.list.category]" => "threat.list.category" }
    #       update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
    #       update => { "[mc][threat.list.comment]" => "threat.list.comment" }
    #       update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
    #       update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
    #       update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
    #       update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
    #       update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
    #       remove_field => ["memcache_value", "mc" ]
    #     }
    #   }
    # }
    if [file.mime_type] and [file.mime_type] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.mime_type"
        get => {
          "%{file.mime_type}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.mime_type" ]
      }
      if "memcached_get_success_file.mime_type" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [user.id] and [user.id] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "user.id"
        get => {
          "%{user.id}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_user.id" ]
      }
      if "memcached_get_success_user.id" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [http.cookie.name] and [http.cookie.name] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "http.cookie.name"
        get => {
          "%{http.cookie.name}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_http.cookie.name" ]
      }
      if "memcached_get_success_http.cookie.name" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [vulnerability.reference] and [vulnerability.reference] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "vulnerability.reference"
        get => {
          "%{vulnerability.reference}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_vulnerability.reference" ]
      }
      if "memcached_get_success_vulnerability.reference" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [file.path] and [file.path] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "file.path"
        get => {
          "%{file.path}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_file.path" ]
      }
      if "memcached_get_success_file.path" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [destination.user.name] and [destination.user.name] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "destination.user.name"
        get => {
          "%{destination.user.name}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_destination.user.name" ]
      }
      if "memcached_get_success_destination.user.name" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [destination.user.email] and [destination.user.email] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "destination.user.email"
        get => {
          "%{destination.user.email}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_destination.user.email" ]
      }
      if "memcached_get_success_destination.user.email" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [destination.address] and [destination.address] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "destination.address"
        get => {
          "%{destination.address}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_destination.address" ]
      }
      if "memcached_get_success_destination.address" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [destination.as.organization.name] and [destination.as.organization.name] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "destination.as.organization.name"
        get => {
          "%{destination.as.organization.name}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_destination.as.organization.name" ]
      }
      if "memcached_get_success_destination.as.organization.name" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [process.name] and [process.name] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "process.name"
        get => {
          "%{process.name}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_process.name" ]
      }
      if "memcached_get_success_process.name" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [tls.server.hash.sha1] and [tls.server.hash.sha1] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "tls.server.hash.sha1"
        get => {
          "%{tls.server.hash.sha1}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_tls.server.hash.sha1" ]
      }
      if "memcached_get_success_tls.server.hash.sha1" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [tls.server.hash.md5] and [tls.server.hash.md5] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "tls.server.hash.md5"
        get => {
          "%{tls.server.hash.md5}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_tls.server.hash.md5" ]
      }
      if "memcached_get_success_tls.server.hash.md5" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [tls.server.hash.sha256] and [tls.server.hash.sha256] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "tls.server.hash.sha256"
        get => {
          "%{tls.server.hash.sha256}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_tls.server.hash.sha256" ]
      }
      if "memcached_get_success_tls.server.hash.sha256" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [destination.port] and [destination.port] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "destination.port"
        get => {
          "%{destination.port}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_destination.port" ]
      }
      if "memcached_get_success_destination.port" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if ( [destination.ip] and [destination.ip] != "" ) and ( [destination.port] and [destination.port] != "" ) {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "destination.ip_destination.port"
        get => {
          "%{destination.ip}|%{destination.port}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_destination.ip_destination.port" ]
      }
      if "memcached_get_success_destination.ip_destination.port" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if ( [destination.address] and [destination.address] != "" ) and ( [destination.port] and [destination.port] != "" ) {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "destination.address_destination.port"
        get => {
          "%{destination.address}|%{destination.port}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_destination.address_destination.port" ]
      }
      if "memcached_get_success_destination.address_destination.port" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [source.mac] and [source.mac] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "source.mac"
        get => {
          "%{source.mac}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_source.mac" ]
      }
      if "memcached_get_success_source.mac" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [source.user.email] and [source.user.email] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "source.user.email"
        get => {
          "%{source.user.email}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_source.user.email" ]
      }
      if "memcached_get_success_source.user.email" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [destination.user.email] and [destination.user.email] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "destination.user.email"
        get => {
          "%{destination.user.email}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_destination.user.email" ]
      }
      if "memcached_get_success_destination.user.email" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [email.subject] and [email.subject] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "email.subject"
        get => {
          "%{email.subject}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_email.subject" ]
      }
      if "memcached_get_success_email.subject" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    # if [file.name] and [file.name] != "" {
    #   memcached {
    #     hosts => ["VAR_MEMCACHED_HOST"]
    #     namespace => "file.name"
    #     get => {
    #       "%{file.name}" => "[memcache_value]"
    #     }
    #     ttl => 60
    #     add_tag => [ "memcached_get_success_file.name" ]
    #   }
    #   if "memcached_get_success_file.name" in [tags] {
    #     kv {
    #     source => "memcache_value"
    #     target => "mc"
    #     }
    #     mutate {
    #       update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
    #       update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
    #       update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
    #       update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
    #       update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
    #       update => { "[mc][threat.list.category]" => "threat.list.category" }
    #       update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
    #       update => { "[mc][threat.list.comment]" => "threat.list.comment" }
    #       update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
    #       update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
    #       update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
    #       update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
    #       update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
    #       remove_field => ["memcache_value", "mc" ]
    #     }
    #   }
    # }
    if [email.body] and [email.body] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "email.body"
        get => {
          "%{email.body}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_email.body" ]
      }
      if "memcached_get_success_email.body" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
    if [email.header] and [email.header] != "" {
      memcached {
        hosts => ["VAR_MEMCACHED_HOST"]
        namespace => "email.header"
        get => {
          "%{email.header}" => "[memcache_value]"
        }
        ttl => 60
        add_tag => [ "memcached_get_success_email.header" ]
      }
      if "memcached_get_success_email.header" in [tags] {
        kv {
        source => "memcache_value"
        target => "mc"
        }
        mutate {
          update => { "[mc][threat.list.event_analysis]" => "threat.list.event_analysis" }
          update => { "[mc][threat.list.member_org]" => "threat.list.member_org" }
          update => { "[mc][threat.list.source_org]" => "threat.list.source_org" }
          update => { "[mc][threat.list.event_info]" => "threat.list.event_info" }
          update => { "[mc][threat.list.severity_name]" => "threat.list.severity_name" }
          update => { "[mc][threat.list.category]" => "threat.list.category" }
          update => { "[mc][threat.list.object_category]" => "threat.list.object_category" }
          update => { "[mc][threat.list.comment]" => "threat.list.comment" }
          update => { "[mc][threat.list.event_tag]" => "threat.list.event_tag" }
          update => { "[mc][threat.list.safe_to_enable_ids]" => "threat.list.safe_to_enable_ids" }
          update => { "[mc][threat.list.object_relation]" => "threat.list.object_relation" }
          update => { "[mc][threat.list.attribute_tag]" => "threat.list.attribute_tag" }
          update => { "[mc][threat.list.object_name]" => "threat.list.object_name" }
          remove_field => ["memcache_value", "mc" ]
        }
      }
    }
  }
}