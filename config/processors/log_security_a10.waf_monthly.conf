input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}
filter {
  mutate {
    add_field => { "event.module" => "a10" }
    add_field => { "event.dataset" => "a10.proxy" }
    add_field => { "observer.vendor" => "a10" }
    add_field => { "observer.product" => "a10 waf" }
    add_field => { "observer.type" => "waf" }
  }
  if [message] =~ "^.*?} a10$" or [message] =~ "^a10$" {
    # drop a10 health checks
    drop {}
  }
### Header
  ### Logstash tcp or udp in
  if [agent.type] == "logstash" {
    mutate {
      add_field => { "agent.parse_rule" => "syslog header" }
    }
    dissect {
      tag_on_failure => "_dateparsefailure_header"
      mapping => {
        message => "<%{pri}> %{rest_msg}"
      }
    }
  } else {
  ### Filebeats udp or tcp in
    mutate {
      add_field => { "agent.parse_rule" => "syslog header" }
    }
    dissect {
      tag_on_failure => "_dateparsefailure_header"
      mapping => {
        message => "%{?data} {%{?data}} <%{pri}> %{rest_msg}"
      }
    }
  }
  syslog_pri {
    syslog_pri_field_name => "pri"
  }

### message
  if [rest_msg] =~ "cef:" {
    dissect {
      add_field => { "agent.parse_rule" => "RULE 1" }
      mapping => {
        "rest_msg" => "%{?data}|%{?data}|%{?data}|%{?data}|%{?data}|%{?data}|%{?data}|rt=%{event.created} %{+event.created} %{+event.created} %{+event.created} src=%{source.ip} spt=%{source.port} dst=%{destination.ip} dpt=%{destination.port} dhost=%{url.domain} cs1=%{rule.category} cs2=%{event.id} act=%{event.action} cs3=%{rule.name} app=%{url.scheme} requestmethod=%{http.request.method} cn1=%{cn1} request=%{url.path} msg=%{rule.description}"
      }
    }
    if [url.domain] {
      mutate {
        add_field => { "url.full" => "%{url.scheme}://%{url.domain}/%{url.path}" }
      }
    }
  } else if [message] =~ "(r|R)esets (C|c)onnection" {
    dissect {
      add_field => { "agent.parse_rule" => "RULE 2" }
      mapping => {
        "rest_msg" => "[%{?data}] %{network.transport} %{source.ip} > %{destination.ip}:%{destination.port} %{?data} %{event.action} %{?data}"
      }
    }
  } else {
    mutate {
      add_field => { "agent.parse_rule" => "no rule match" }
      rename => { "rest_msg" => "log.original" }

    }
  }

  translate {
    field => "[event.action]"
    destination => "[rule.category]"
    dictionary => {
      "allow" => "Ops Network allow"
      "deny" => "Ops Network deny"
      "sanitize" => "Ops Other"
    }
    fallback => "Others"
  }
### Clean up
  # event.created = jan 06 2021 15:14:53
  date {
    match => ["event.created","MMM dd yyyy HH:mm:ss"]
    timezone => "GMT"
    locale => "en"
    target => "event.created"
    tag_on_failure => "_dateparsefailure_ec"
  }
  if "_dateparsefailure_ec" in [tags] {
    if ![log.original] {
      mutate {
        copy => { "message" => "log.original" }
      }
    }
    mutate {
      remove_field => ["event.created"]
    }
  }
  mutate {
    remove_field => ["rest_msg", "pri", "cn1"]
    add_field => { "ecs.version" => "1.7" }
    add_field => { "observer.vendor" => "a10" }
    add_field => { "observer.product" => "a10 web application firewall" }
    add_field => { "observer.type" => "waf" }
  }
}
output {
  pipeline { send_to => [enrichments] }
}