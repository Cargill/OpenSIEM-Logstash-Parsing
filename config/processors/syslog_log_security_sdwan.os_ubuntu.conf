# Copyright [2021] [Cargill, Incorporated.] 
# SPDX-License-Identifier: Apache-2.0
input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}




filter {
  mutate {
    add_field => { "event.module" => "sdwan.os_ubuntu" }
    add_field => { "observer.vendor" => "versa" }
    add_field => { "observer.product" => "versa.sdwan.os_ubuntu" }
    add_field => { "observer.type" => "network_management" }
  }
    
  # 1. start by copying the original message to log.original.  we'll then pick the common fields and placing them under [tmp]. [tmp] is a temporary slot to work out the parsing

  mutate {
    id => "sdwan.os-mutate-logoriginal"
    tag_on_failure => "_mutate_error-sdwan.os-logoriginal"
    add_field => {"[log.original]" => "%{[message]}"}
    
  }
  mutate {
    lowercase => ["[message]"]
  }

  # 2. OS log format is not consistent. The easiest way to parse seem to be identifying the log type first and then using common parsing that work for that given process

  if "com.tailf.ncs.alarmman.common.alarm" in [message]
  {
    mutate {
      add_field => { "[tmp][type]" => "alarmman"}
    }
    dissect {
      id => "sdwan.os-dissect-alarmman"
      tag_on_failure => "_dissect_error-sdwan.os-alarmman"
      mapping => {
        "message" => "%{} %{} <%{[syslog_pri]}>%{[tmp][date]}  %{+[tmp][date]} %{+[tmp][date]} %{[observer][hostname]} %{[tmp][process]} %{} %{[tmp][rest_msg]}"
        
      }
    }
    syslog_pri {}
    mutate {
      rename => { "syslog_severity_code" => "log.syslog.severity.code"}
      rename => { "syslog_severity" => "log.syslog.severity.name"}
      rename => { "syslog_facility" => "log.syslog.facility.name"}
      rename => { "syslog_facility_name" => "log.syslog.facility.code"}
    }
    grok {
      match => {"[tmp][rest_msg]" => "%{WORD}%{NOTSPACE}\[%{GREEDYDATA}\],type=%{NOTSPACE},%{GREEDYDATA:[tmp][rest_msg_2]}" }
    }
    kv {
      field_split_pattern => "\,"
      source => "[tmp][rest_msg_2]"
      target => "[tmp][details]"
    }
    grok {
      match => {"[tmp][details][alarm-text]" => "%{NOTSPACE:[error.type]} versa appliance %{NOTSPACE:[host][hostname]}.*:%{GREEDYDATA:[error.message]}"}
    }
    mutate{
      strip => ["[error.type]", "[error.message]"]
      # gsub =>  [
      #   "error.type"
      # ]
      add_field => {"event.dataset" => "%{event.module}.%{[tmp][type]}" }
    }
    mutate {
      remove_field => ["[tmp]"]
    }
  
  }

  #this is a more generic parse but don't expect it to work on all kinds of messages
  else {
    dissect {
        id => "sdwan.os-dissect"
        tag_on_failure => "_dissect_error-sdwan.os-message"
        mapping => {
        "message" => "%{} %{[tmp][host]} %{[tmp][rest_msg]}"
        }
  }
  
  }

}


output {
  pipeline { send_to => [enrichments] }
}
