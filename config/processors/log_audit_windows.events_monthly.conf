input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}
filter {
  if [message] =~ "Z {name=" {
    mutate {
      add_field => {"parse_rule_name" => "non domain servers"}
    }
    dissect {
      mapping => {
        message => "%{?log.date} {%{?data}} %{rest_msg}"
      }
    }
    mutate {
      gsub => ["rest_msg","\n\t",","]
      gsub => ["rest_msg","\t",""]
    }
    kv {
      source => "rest_msg"
      field_split => ","
      value_split => ":"
      trim_key => " "
      target => "win"
    }
    mutate {
      rename => {"[win][Source Address]" => "source.ip"}
      rename => {"[win][Destination Address]" => "destination.ip"}
      rename => {"[win][Process ID]" => "process.pid"}
      rename => {"[win][Direction]" => "network.direction"}
      rename => {"[win][Destination Port]" => "destination.port"}
      rename => {"[win][Source Port]" => "source.port"}
      rename => {"[win][Account Domain]" => "user.domain"}
			rename => {"[win][Account Name]" => "user.id"}
    }
    mutate { remove_field => ["rest_msg","[win]"]}
  }
  else {
    json {
      source => "message"
    }
    # Not sure if these need to be nested or not (i.e. will Event_ID
    # need to be winlog.Event_ID)
    mutate {
      rename => {"[winlog][event_data][ActionName]" => "event.action"}
      rename => {"[winlog][keywords]" => "rule.category"}
      rename => {"[winlog][channel]"  => "event.dataset"}
      rename => {"[winlog][provider_name]" => "event.module"}
      # User
      rename => {"[winlog][user][domain]" => "user.domain"}
      rename => {"[winlog][user][name]" => "user_name"}
      # Destination
      rename => {"[winlog][event_data][TargetLogonGuid]" => "destination.user.group.id"}
      rename => {"[winlog][event_data][TargetDomainName]" => "destination.domain"}
      rename => {"[winlog][event_data][TargetOutboundUserName]" => "destinationuser_name"}
      rename => {"[winlog][event_data][TargetUserName]" => "hostuser_name"}
      rename => {"[winlog][event_data][DestAddress]" => "destination.ip"}
      rename => {"[winlog][event_data][Group]"  => "destination.user.group.name"}
      rename => {"[winlog][event_data][DestPort]" => "destination.port"}
      # File
      rename => {"[winlog][event_data][OriginalFileName]" => "file.path"} 
      rename => {"[winlog][event_data][Path]" => "file.path"}
      rename => {"[winlog][event_data][ShareLocalPath]" => "file.target_path"}
      rename => {"[winlog][event_data][ObjectName]" => "file.path"}
      # Process fields
      rename => {"[winlog][event_data][TaskName]" => "process.name"}
      rename => {"[winlog][event_data][ProcessID]" => "process.pid"}
      rename => {"[winlog][user_data][ProcessID]" => "process.pid"}
      rename => {"[winlog][event_data][NewProcessName]" => "process.path"}
      rename => {"[winlog][event_data][ProcessName]" => "process.name"}
      rename => {"[winlog][event_data][ServiceName]" => "process.name"}
      rename => {"[winlog][event_data][ServiceSid]" => "process.pid"}
      rename => {"[winlog][event_data][ParentProcessName]" => "process.parent.name"}
      rename => {"[winlog][event_data][LogonProcessName]" => "process.name"}
      rename => {"[winlog][event_data][Application]" => "process.name"}
      rename => {"[winlog][event_data][ObjectType]" => "process.args"}
      rename => {"[winlog][event_data][SourceProcessId]" => "process.parent.pid"}
      rename => {"[winlog][event_data][ProcessId]" => "process.pid"}
      rename => {"[winlog][event_data][winlog.event_data.ProcessPath]" => "process.path"}
      rename => {"[winlog][event_data][winlog.event_data.ProcessPid]" => "process.pid"}
      # Source
      rename => {"[winlog][event_data][SubjectDomainName]" => "source.user.domain"}
      rename => {"[winlog][event_data][IpAddress]" => "source.ip"}
      rename => {"[winlog][event_data][IpPort]" => "source.port"}
      rename => {"[winlog][event_data][SourceAddress]" => "source.ip"}
      rename => {"[winlog][event_data][SourcePort]" => "source.port"}
      rename => {"[winlog][event_data][SubjectUserName]" => "sourceuser_name"}
      rename => {"[winlog][event_data][winlog.event_data.SubjectUserSid]" => "sourceuser_id"} 
      rename => {"[winlog][event_data][LogonType]" => "event.id"}
      rename => {"[winlog][event_data][Status]" => "event.code"}
      rename => {"[winlog][event_data][Protocol]" => "network.iana_number"}
      # Host
      rename => {"[winlog][computer_name]" => "log.source.hostname"}
      rename => {"[winlog][event_data][WorkstationName]" => "log.source.hostname"}
      # Other 
      rename => {"[winlog][event_data][PackageName]" => "package.name"}
      # drop process.pid as it is not useful, and we see hex values for them
      remove_field => [ "winlog", "process.pid", "process.parent.pid" ]
    }
    # spliting user id and domain
    if [user_name] {
      if [user_name] =~ "@" {
        dissect {
          mapping => {
            user_name => "%{user.name}@%{user.domain}"
          }
        }
        mutate {remove_field => ["user_name"]}
      }
      else {
        mutate {
          rename => {"user_name" => "user.name"}
        }
      }
    }
    if [sourceuser_name] {
      if [sourceuser_name] =~ "@" {
        dissect {
          mapping => {
            sourceuser_name => "%{source.user.name}@%{source.user.domain}"
          }
        }
        mutate {remove_field => ["sourceuser_name"]}
      }
      else {
        mutate {
          rename => {"sourceuser_name" => "source.user.name"}
        }
      }
    }
    if [destinationuser_name] {
      if [destinationuser_name] =~ "@" {
        dissect {
          mapping => {
            destinationuser_name => "%{destination.user.name}@%{destination.user.domain}"
          }
        }
        mutate {remove_field => ["destinationuser_name"]}
      }
      else {
        mutate {
          rename => {"destinationuser_name" => "destination.user.name"}
        }
      }
    }
    if [sourceuser_id] {
      if [sourceuser_id] =~ "@" {
        dissect {
          mapping => {
            sourceuser_id => "%{source.user.id}@%{source.user.domain}"
          }
        }
        mutate {remove_field => ["sourceuser_id"]}
      }
      else {
        mutate {
          rename => {"sourceuser_id" => "source.user.id"}
        }
      }
    }
    if [hostuser_name] {
      if [hostuser_name] =~ "@" {
        dissect {
          mapping => {
            hostuser_name => "%{host.user.name}@%{host.user.domain}"
          }
        }
        mutate {remove_field => ["hostuser_name"]}
      }
      else {
        mutate {
          rename => {"hostuser_name" => "host.user.name"}
        }
      }
    }
    if [source.ip] {
      if [source.ip] =~ "::ffff:" {
        mutate {
          gsub => ["source.ip","::ffff:",""]
        }
      }
    }
    if [destination.ip] {
      if [destination.ip] =~ "::ffff:" {
        mutate {
          gsub => ["destination.ip","::ffff:",""]
        }
      }
    }
  }
  if [event.code] == "5829" {
    grok {
      match => { "message" => "^(?<error.message>.*?) \r\n\r\nWarning: (.*?please visit  (?<event.reference>.*?)\.\s+)\r\n\r\n.*?Machine SamAccountName: (?<observer.name>.*?) \r\n.*?Domain: (?<source.domain>.*?\.) \r\n.*?Account Type:" }  
    }
  }
  
}
output {
  pipeline { send_to => [enrichments] }
}