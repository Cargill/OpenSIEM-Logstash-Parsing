input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}
filter {
  mutate {
    add_field => { "event.module" => "cisco.stealthwatch" }
    add_field => { "event.dataset" => "cisco.stealthwatch" }
    add_field => { "observer.vendor" => "cisco" }
    add_field => { "observer.product" => "cisco.stealthwatch" }
    add_field => { "observer.type" => "net_flow" }
  }
  ### Header
  ### Logstash tcp or udp in
  if [agent.type] == "logstash" {
    dissect {
      tag_on_failure => "_dateparsefailure_header"
      mapping => {
        message => "<%{pri}> %{rest_msg}"
      }
    }
  } else {
  ### Filebeats udp or tcp in
    dissect {
      tag_on_failure => "_dateparsefailure_header"
      mapping => {
        message => "%{?data} {%{?data}} <%{pri}> %{rest_msg}"
      }
    }
  }
  syslog_pri {
    syslog_pri_field_name => "pri"
  }
  mutate {
    remove_field => ["pri"]
  }
  mutate {
    strip => ["message"]
  }
  if [message] =~ "{name=" {
    dissect {
      mapping => {
        message => "%{log.date_time} %{?data}>%{event.created->} %{+event.created} %{+event.created} %{source.address} %{process.name}[%{process.pid}]: %{rest_msg}"
      }
    }
  }
  else {
    dissect {
      mapping => {
        message => "%{log.date_time} %{?data}>%{event.created->} %{+event.created} %{+event.created} %{source.address} %{process.name}[%{process.pid}]: %{rest_msg}"
      }
    }
  }
  if [rest_msg] !~ "=" and [rest_msg] !~ "|" {
    mutate {
      add_field => { "agent.parse_rule" => "RULE 1" }
    }
    dissect {
      mapping => {
        "rest_msg" => "%{?data},%{source.port},%{?event.start},%{rule.name},%{destination.ip},%{?data},%{event.action}"
      }
    }
    if[process.name] =~ "System time" {
      mutate {
        add_field => { "agent.parse_rule" => "RULE 3" }
      }
      mutate {
        add_field => {
          "rule.category" => "Audit/Information"
        }
      }
    }
    else{
      mutate {
        add_field => { "agent.parse_rule" => "RULE 4" }
      }
      mutate {
        add_field => {
          "rule.category" => "Others"
        }
      }
    }
  }
  else if [rest_msg] =~ "=" and [rest_msg] =~ "|"{
    mutate {
      add_field => { "agent.parse_rule" => "RULE 5" }
    }
    kv {
      source => "rest_msg"
      field_split => "|"
      value_split => "="
      target => "sw"
    }
    mutate {
      rename => {"[sw][SourceHostname]" => "source.address"}
      rename => {"[sw][TargetMacAddress]" => "destination.mac" }
      rename => {"[sw][Duration]" => "event.duration" }
      rename => {"[sw][SourceIP]" => "source.ip" }
      rename => {"[sw][event.status]" => "rule.description" }
      rename => {"[sw][TargetHostname]" => "destination.address" }
      rename => {"[sw][Target]" => "destination.ip" }
      rename => {"[sw][Port]" => "destination.port" }
      rename => {"[sw][AlarmID]" => "event.id" }
      rename => {"[sw][AlarmName]" => "rule.name" }
      rename => {"[sw][AlarmSeverity]" => "event.severity_name" }
    }
    mutate {
      remove_field => ["[sw]"]
      add_field => {
        "rule.category" => "Audit/Information"
      }
    }
  }
  else if "=" not in [rest_msg] and "|" not in [rest_msg] {
    mutate {
      add_field => { "agent.parse_rule" => "RULE 1 (no_pipe)" }
    }
    dissect {
      mapping => {
        "rest_msg" => "%{?data},%{source.port},%{event.start}+%{?data},%{rule.name},%{destination.ip},%{?data},%{event.action}"
      }
    }
    date{
      match => ["event.start", "MMM dd HH:mm:ss", "ISO8601","yyyy-MM-dd'T'HH:mm:ss'TZD'"]
      timezone => "GMT"
      locale => "en"
      target => "event.start"
    }
  }
  else if [rest_msg] !~ "=" and [rest_msg] =~ "|" {
    mutate {
      add_field => { "agent.parse_rule" => "RULE 1 (a)" }
    }
    dissect {
      mapping => {
        "rest_msg" => "%{?data},%{source.port},%{event.start}+%{?data},%{rule.name}|%{?data},%{destination.ip},%{?data},%{event.action}"
      }
    }
    date{
      match => ["event.start", "MMM dd HH:mm:ss", "ISO8601","yyyy-MM-dd'T'HH:mm:ss'TZD'"]
      timezone => "GMT"
      locale => "en"
      target => "event.start"
    }
  }
  date{
    match => ["event.created", "MMM dd HH:mm:ss", "MMM d HH:mm:ss"]
    timezone => "GMT"
    locale => "en"
    target => "event.created"
  }
  mutate{
    # host field comes as part of json, it's also in the log and we are parsing it already
    remove_field => ["log.date_time","rest_msg", "host", "port"]
  }
}
output {
  pipeline { send_to => [enrichments] }
}