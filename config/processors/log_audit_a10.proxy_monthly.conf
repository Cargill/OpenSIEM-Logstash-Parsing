input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}
filter {
  mutate {
    add_field => { "organization.name" => "cargill" }
    add_field => { "event.module" => "a10" }
    add_field => { "event.dataset" => "a10.proxy" }
    add_field => { "observer.vendor" => "a10" }
    add_field => { "observer.product" => "a10 loadbalancer" }
    add_field => { "observer.type" => "proxy" }
  }
  ### Header
  ### Logstash tcp or udp in
  if [agent.type] == "logstash" {
    dissect {
      tag_on_failure => "_dateparsefailure_header"
      mapping => {
        message => "<%{pri}> %{rest_msg}"
      }
    }
  } else {
  ### Filebeats udp or tcp in
    dissect {
      tag_on_failure => "_dateparsefailure_header"
      mapping => {
        message => "%{?data} {%{?data}} <%{pri}> %{rest_msg}"
      }
    }
  }
  syslog_pri {
    syslog_pri_field_name => "pri"
  }
  mutate{
    remove_field => ["pri"]
  }
  if [message] == "" {
    drop {}
  }
  mutate {
    strip => ["message"]
  }
  dissect {
    mapping => {
      "message" => "%{?data} %{check_data}"
    }
  }
  if [check_data] !~ " " {
    drop {}
  } else {
    dissect {
      mapping => {
        "message" => "%{log.date} {%{?data}} %{rest_msg}"
      }
    }
    if [message] =~ "cs1=WAF_Learning" {

      dissect {
        add_field => { "agent.parse_rule" => "RULE 1" }
        mapping => {
          "rest_msg" => "<%{syslog_pri}>%{observer.hostname}=%{event.created->} %{+event.created} %{+event.created} %{+event.created} src=%{source.address} spt=%{source.port} dst=%{destination.ip} dpt=%{destination.port} dhost=%{destination.address} cs1=%{waf.policy.name} cs2=%{cs2} act=%{event.action} cs3=%{policy.style} app=%{network.protocol} requestMethod=%{http.request.method} cn1=%{cn1} %{http.request.body.content} %{event.message}"
        }
      }
    }
    else if [message] =~ "External_Logging_Alfex:" {
      dissect {
        add_field => { "agent.parse_rule" => "RULE 2" }
        mapping => {
          "rest_msg" => "<%{syslog_pri}> %{process.name}:%{event.created->} %{+event.created} %{+event.created} %{source.ip}:%{source.port} -> %{destination.ip}:%{destination.port} %{?data} %{source.address} %{?data} %{url.path}"
        }
      }
    } else if [message] =~ "(r|R)esets (C|c)onnection" {
      dissect {
        add_field => { "agent.parse_rule" => "RULE 3" }
        mapping => {
          "rest_msg" => "<%{syslog_pri}>%{event.created->} %{+event.created} %{+event.created} %{observer.hostname} %{?data} %{?data} [%{?data}] %{network.transport} %{source.address} > %{destination.ip}:%{destination.port} %{event.original}"
        }
      }
    } else {
        mutate {
          add_field => { "agent.parse_rule" => "Not Parsed" }
        }
      }


  mutate {
    add_field => { "observer.vendor" => "a10" }
    add_field => { "observer.product" => "a10 web application firewall" }
    add_field => { "observer.type" => "waf" }
  }
  syslog_pri {
    syslog_pri_field_name => syslog_pri
  }

  date {
    match => ["event.created" , "MMM dd yyyy HH:mm:ss", "MMM dd yyyy HH:mm:ss.SSS", "yyyy-mm-dd HH:mm:ss", "yyyy-mm-dd HH:mm:ss.SSS", "MMM dd HH:mm:ss" ,"MMM dd HH:mm:ss.SSS","yyyy/MM/dd 'at' HH:mm:ss"]
    timezone => "GMT"
    locale => "en"
    target => "event.created"
    tag_on_failure => "_dateparsefailure_ec"
  }

  if "_dateparsefailure_ec" in [tags]  {
    if ![log.orignal] {
      mutate {
        copy => { "message" => "log.original" }
      }
    }
    mutate {
     remove_field => ["event.created"]
    }
  }


  syslog_pri {
    syslog_pri_field_name => syslog_pri
  }
  mutate {
    remove_field => ["log.date", "rest_msg", "rest_msg", "code", "event.message","cs2","cn1","check_data"]
    #  add_field => { "ecs.version" => "1.4" }
  }
  #### Classification part ####
  translate {
    field => "[event.action]"
    destination => "[rule.category]"
    dictionary => {
      "allow" => "Ops Network allow"
      "deny" => "Ops Network deny"
      "sanitize" => "Ops Other"
    }
    fallback => "Others"
  }
  }
}
output {
  pipeline { send_to => [enrichments] }
}