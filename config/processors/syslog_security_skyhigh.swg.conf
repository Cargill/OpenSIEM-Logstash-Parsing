# Copyright [2021] [Cargill, Incorporated.] 
# SPDX-License-Identifier: Apache-2.0
# MWG requires a specific configuration to receive logs in the format being parsed below. You can find the configuration/
# setup details in the "doc/log_configurations" directory.
input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}
filter {
  # 
  mutate {
    remove_field => [ "host","event" ]
    add_field => { "[event][module]" => "skyhigh" }
    add_field => { "[event][dataset]" => "skyhigh.swg" }
    copy => { "message" => "[event][original]" }	
    gsub => [
      "message", "connection type=(.*?), ssl", "connection type=\1,  ssl"
    ]
  }
  grok {
    match => { "message" => "^(.*?)(<(?<pri>\d+)>)(\s)?.*?mwg:(  )?(?<tmp_csv>.*?)$" }
    timeout_millis => 500
  }
  syslog_pri {
    syslog_pri_field_name => "pri" 
    remove_field => [ "pri" ]
	ecs_compatibility => v8
  }
  if [tmp_csv] !~ "\w,\w" {
    kv {
      source => "tmp_csv"
	  target => "tmp"
      field_split_pattern => ",(  | $)"
      value_split => "="
	  recursive => "true"
      trim_key => " "
	  trim_value => " "
    }
  } else {
    kv {
      source => "tmp_csv"
	  target => "tmp"
      field_split => ","
      value_split => "="
	  recursive => "true"
      trim_key => " "
	  trim_value => " "
    }
  }
  if [tmp_csv] !~ "ref=.*?$" {
    mutate {
      # identify long uri i.e. possible DNS exfiltration
      add_tag => "long uri"
    }
  }
  mutate {
    rename => {
      "[tmp][usr]" => "[user][name]"
      "[tmp][app]" => "[process][name]"
      "[tmp][block]" => "[rule][ruleset]"
      "[tmp][rbytes]" => "[http][request][bytes]"
      "[tmp][sprt]" => "[source][port]"
      "[tmp][rule]" => "[rule][uuid]"
      "[tmp][stat]" => "[http][response][status_code]"
      "[tmp][agent]" => "[user_agent][original]"
      "[tmp][sbytes]" => "[http][response][bytes]"
      "[tmp][blockid]" => "[rule][id]"
      "[tmp][sip]" => "[source][ip]"
      "[tmp][sev]" => "[event][severity_name]"
      "[tmp][ref]" => "[http][request][referrer]"
      "[tmp][dip]" => "[destination][ip]"
      "[tmp][cat]" => "[rule][category]"
      "[tmp][ts]" => "[event][created]"
      "[tmp][dprt]" => "[destination][port]"
      "[tmp][media]" => "[http][response][mime_type]"
      "[tmp][sslsigmethodserver]" => "[tls][server][x509][signature_algorithm]"
      "[tmp][sslciphersrvrt]" => "[tls][cipher]"
      "[tmp][sslversionsrvr]" => "[tls][version]"
      "[tmp][sslsha2digestsrvr]" => "[tls][server][hash][sha256]"
      "[tmp][sslsha1digestsrvr]" => "[tls][server][hash][sha1]"
      "[tmp][sslcnsrvr]" => "[tls][server][issuer]"
      "[tmp][sslcipherclient]" => "[tls][client][supported_ciphers]"
      "[tmp][sslversionclient]" => "[tls][client][x509][version_number]"
      "[tmp][sslcertserialclient]" => "[tls][client][x509][serial_number]"
      "[tmp][mprob]" => "[event][risk_score]"
      "[tmp][virus]" => "[rule][name]"
      "[tmp][ver]" => "[tls][next_protocol]"
      "[tmp][url]" => "[observer][ip]"
    }
  }
  # URI
  grok {
    match => { "[tmp][method]" => "^(?<[http][request][method]>.*?) (?<[url][full]>.*?)( |$)((?<[tls][next_protocol]>.*?).*$)?" }
    tag_on_failure => "_grokparsefailure_uri"
    timeout_millis => 500
  }

  translate {
    source => "[[rule][id]]"
    target => "[rule][description]"
    dictionary => {
      "0" => "Allowed"
      "1" => "Internal error"
      "2" => "Default message template being used for an action"
      "3" => "Internal URL error"
      "10" => "Blocked due to an entry in the URL database"
      "14" => "Blocked according to URL ing by expression"
      "15" => "Blocked by the Real-Time Classifier"
      "20" => "Blocked due to lack of content type"
      "22" => "Blocked due to the media type"
      "30" => "Blocked due to a multi-part archive having been found"
      "35" => "Blocked due to an archive not handled by the Archive Handler"
      "80" => "Blocked due to a virus having been found"
      "81" => "Blocked due to unauthorized access"
      "82" => "Blocked due to a bad request"
      "85" => "Blocked due to an internal anti-malware error"
      "92" => "Blocked due to expiration of a certificate"
      "93" => "Blocked due to a revoked certificate"
      "94" => "Blocked due to a forbidden certificate authority (CA)"
      "95" => "Blocked due to an unknown certificate authority (CA)"
      "97" => "Blocked due to a self-signed certificate"
      "98" => "Blocked due to a common name mismatch"
      "102" => "Blocked due to an unspecified certificate incident"
      "103" => "Blocked due to CONNECT not allowed"
      "104" => "Blocked due to the reverse proxy destination not being allowed"
      "140" => "Blocked due to an internal DLP  error"
      "150" => "Blocked due to an internal Application Control  error"
      "151" => "Blocked due to a request belonging to an application that is not allowed"
      "160" => "Blocked due to missing policy for Web Hybrid"
      "161" => "Blocked due to web access not being allowed by Web Hybrid"
      "162" => "Blocked due to URL ing by Web Hybrid"
      "200" => "Blocked due to the coaching session of a user having been exceeded"
      "201" => "Blocked due to the time quota session of a user having been exceeded"
      "202" => "Blocked due to the time quota for a user having been exceeded"
      "203" => "Blocked due to the volume quota session of a user having been exceeded"
      "204" => "Blocked due to the volume quota for a user having been exceeded"
      "205" => "Blocked due to the authorized override session of a user having been exceeded"
      "206" => "Blocked due to the blocking session of a user being active"
      "300" => "Blocked due to a quota redirect"
      "301" => "Blocked due to an authentication redirect"
      "400" => "Blocked due to an authorized override redirect"
    }
    fallback => "Others"
  }
  if [rule][description] =~ "Allowed" {
    mutate {
      add_field => { "[event][action]" => "allowed" }
    }
  }
  if [rule][description] =~ "Blocked" {
    mutate {
      add_field => { "[event][action]" => "denied" }
    }
  }
  
  if [event][created] {
    date {
      # "26/aug/2020:19:35:09.533 +0000"
      # ts=[12/oct/2020:17:24:01 +0000]
      match => ["[event][created]", "ISO8601","MMM dd HH:mm:ss","dd/MMM/yyyy:HH:mm:ss ZZ"  ]
      timezone => "GMT"
      locale => "en"
      target => "[event][created]"
      tag_on_failure => "_dateparsefailure_ec"
    }
  }
  if [http][request][referrer] == "," {
    mutate {
      remove_field => ["[http][request][referrer]"]
    }
  }
  mutate {
    remove_field => ["tmp", "tmp_csv"]
  }
}
output {
  pipeline { send_to => [enrichments] }
}
