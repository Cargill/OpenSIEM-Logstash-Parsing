input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}

filter {
  mutate {
    strip => ["message"]
    gsub => ["message" , '[\"]' , ""]
    gsub => ["message" , '[\"\"]' , ""]
  }
  dissect {
    mapping => {
    message => "[%{log_time}] [%{log.level}] [client %{source.address}] %{error_message}"
    }
  }
  mutate {
    # add source.ip as recommended in ECS
    add_field => {
      "source.ip" => "%{source.address}" 
      "error_type" => "other error"
    }
    remove_field => [ "log_time"]
  }
  # store log_time in @timestamp
  if [error_message] =~ "^Invalid URI in request" {
    mutate {
      add_field => { "parse_rule_name" => "RULE 1" }
    }
    dissect {
      mapping => {
        error_message => "Invalid URI in request %{http_verb} %{request_value}"
      }
    }
    mutate { update => { error_type => "invalid uri" } }
  } else if [error_message] =~ "^Invalid method in request" {
    mutate {
      add_field => { "parse_rule_name" => "RULE 2" }
    }
    dissect {
      mapping => {
        error_message => "Invalid method in request %{http_verb} %{http_version}"
      }
    }
    mutate { update => {error_type => "invalid method" } }
  } else if [error_message] =~ "^client sent invalid" {
    mutate {
      add_field => { "parse_rule_name" => "RULE 3" }
    }
    dissect {
      mapping => {
        error_message => "client sent invalid %{http_version} request: %{http_verb} %{request_uri}"
      }
    }
    mutate { update => {error_type => "invalid request" } }
  } else if [error_message] =~ "^request failed: error reading the headers" or [error_message] =~ "^Client sent malformed Host header" {
    mutate {
      add_field => { "parse_rule_name" => "RULE 4" }
    }
    mutate { update => {error_type => "invalid header" } }
  } else if [error_message] =~ "without hostname" {
    mutate {
      add_field => { "parse_rule_name" => "RULE 5" }
    }
    mutate { update => {error_type => "invalid request" } }
  }
  
}
output {
  pipeline { send_to => [enrichments] }
}