# Logs are sent SIEM using the syslog functionality of MWG.
# To send logs to MWG, the rsyslogd.conf file must be modified.  The most current version of this is documented in the installation process managed by the operations team.
# The maximum message size needs to be set at 6k ($MaxMessagesize 6k) and the remote server to send the logs must also be defined (daemon.notice@@ip.of.siem.server)
# Access logs are sent in the current format to SIEM for proper processing as identified in the Syslog rule in MWG.  
# Below is what the logs in the Rule
#
# Also needed is to configure a Log Handler Rule Set with two rules.  Currently called Syslog.  The first rule creates the syslog message, the second sends the log.
# "Generate Syslog message"
#   Always (Criteria)
#   Continue (Action)
#   Event:
#			Set User-Defined.logLine(2) = String.Concat (" sip=", String.Concat (IP.ToString (Client.IP), ", "))
#			String.Concat (" usr=", String.Concat (Authentication.UserName, ", "))
#			String.Concat (" sprt=", String.Concat (Number.ToString (Connection.Port), ", "))
#			String.Concat (" stat=", String.Concat (Number.ToString (Response.StatusCode), ", "))
#			String.Concat (" cat=", String.Concat (List.OfCategory.ToString (URL.Categories), ", "))
#			String.Concat (" sev=", String.Concat (URL.ReputationString, ", "))
#			String.Concat (" media=", String.Concat (MediaType.ToString (MediaType.FromHeader), ", "))
#			String.Concat (" rbytes=", String.Concat (Number.ToString (BytesToClient), ", "))
#			String.Concat (" sbytes=", String.Concat (Number.ToString (BytesFromClient), ", "))
#			String.Concat (" agent=", String.Concat (Header.Request.Get ("User-Agent"), ", "))
#			String.Concat (" virus=", String.Concat (Header.Request.Get (List.OfString.ToString (Antimalware.VirusNames, "")), ", "))
#			String.Concat (" blockid=", String.Concat (Number.ToString (Block.ID), ", "))
#			String.Concat (" block=", String.Concat (Block.Reason, ", "))
#			String.Concat (" app=", String.Concat (Application.ToString (Application.Name), ", "))
#			String.Concat (" dip=", String.Concat (IP.ToString (URL.Destination.IP), ", "))
#			String.Concat (" dprt=", String.Concat (Number.ToString (URL.Port), ", "))
#			String.Concat (" sslcertserialclient=", String.Concat (SSL.Client.Certificate.Serial, ", "))
#			String.Concat (" sslcipherclient=", String.Concat (SSL.Client.Cipher, ", "))
#			String.Concat (" sslversionclient=", String.Concat (SSL.Client.Protocol, ", "))
#			String.Concat (" sslcnsrvr=", String.Concat (SSL.Server.Certificate.CN, ", "))
#			String.Concat (" sslsha1digestsrvr=", String.Concat (SSL.Server.Certificate.SHA1Digest, ", "))
#			String.Concat (" sslsha2digestsrvr=", String.Concat (SSL.Server.Certificate.SHA2-256Digest, ", "))
#			String.Concat (" sslsigmethodserver=", String.Concat (SSL.Server.Certificate.SignatureMethod, ", "))
#			String.Concat (" sslciphersrvrt=", String.Concat (SSL.Server.Cipher, ", "))
#			String.Concat (" sslversionsrvr=", String.Concat (SSL.Server.Protocol, ", "))
#			String.Concat (" method=", String.Concat (Request.Header.FirstLine, ", "))
#			String.Concat (" ref=", String.Concat (Header.Request.Get ("Referer"), " "))
#
# Below is what each field represents
#	  ts=timestamp in WebReporter format
# 	sip=Client/User IP
#	  usr=username
# 	sprt=Source Port (Connection Port)
#	  cat=URL Categories
# 	sev=Reputation
#	  media=Media Type From Header
# 	rbytes=Bytes Received
#	  sbytes=Bytes Sent
# 	agent=User Agent string
#	  virus=Virusname
# 	blockid=Block ID
#	  block=Block Reason
# 	app=Application Name
#	  dip=Destination IP
# 	dprt=Destination Port
#	  src=Status Code
# 	sslcertserialclient=SSL Certificate Serial Number
#	  sslcipherclient=Client Cipher Suite
# 	sslversionclient=Client TLS Protocol
#	  sslcnsrvr=Server Certificate Common Name (CN)
# 	sslsha1digestsrvr=Server Certificate SHA1Digest
#	  sslsha2digestsrvr=Server Certificate 256Digest
#   sslsigmethodserver=Server Certificate Signature Method
#   sslciphersrvrt=Server Cipher Suite
#   sslversionsrvr=Server TLS Protocol
#   method=Method (i.e. PUT, GET, POST, etc)
#     url=URL
#     ver=Protocol and Version
#   ref=Referer field
#
# The second rule in the rules set sends the log generated above to syslog as a level 5 message.
#

input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}
filter {

  ### If reagular MWG traffic log
  if [message] =~ "method=" {
    dissect {
      tag_on_failure => "_dissectfailure_2"
      mapping => {
        "message" => '%{} {name=%{?data}} <%{pri}>%{?data} ts=%{event.created},  sip=%{source.ip},  usr=%{user.name},  sprt=%{source.port},  stat=%{http.response.status_code},  cat=%{rule.category},  sev=%{event.severity_name},  media=%{http.request.body.content},  rbytes=%{http.response.bytes},  sbytes=%{http.request.bytes},  agent=%{user_agent.original},  virus=%{rule.name},  blockid=%{rule.id},  block=%{rule.ruleset},  app=%{network.application},  dip=%{destination.ip},  dprt=%{destination.port},  sslcertserialclient=%{tls.client.certificate},  sslcipherclient=%{tls.client.supported_ciphers},  sslversionclient=%{tls.client.x509.version_number},  sslcnsrvr=%{tls.server.issuer},  sslsha1digestsrvr=%{tls.server.hash.sha1},  sslsha2digestsrvr=%{tls.server.hash.sha256},  sslsigmethodserver=%{tls.server.x509.signature_algorithm},  sslciphersrvrt=%{tls.cipher},  sslversionsrvr=%{tls.version},  method=%{tmp}'
      }
    }
  ### MWG error logs 
  } else if [message] =~ "Severity: " {
    mutate {
      gsub => ["message",'[\"]',","]
    }
    dissect {
      tag_on_failure => "_dissectfailure_3"
      mapping => {
        "message" => "%{} {name=%{?data}} <%{pri}>%{?data} %{?data} %{?data} %{observer.address} %{rest_msg}"
      }
    }
    if [rest_msg] =~ "user" {
      dissect {
        tag_on_failure => "_dissectfailure_4"
        mapping => {
          rest_msg => "%{?data},%{?data},%{?data},%{event.action},%{?data},%{?data} ,%{user.name}, (%{source.ip}),%{?data},Severity: %{log.level}"
        }
      }
    } else {
      dissect {
        tag_on_failure => "_dissectfailure_5"
        mapping => {
          rest_msg => "%{?data},%{?data},%{?data},%{event.action},%{?data},%{rule.description},%{?data},Severity: %{log.level}"
        }
      }
    }
  }
  syslog_pri {
        syslog_pri_field_name => "pri"
      }

  mutate {
      gsub => [ 
        "event.created", "\[", "",
        "event.created", "\]", ""
      ]
  }
  if [tmp] !~ "ref=.*?$" {
    mutate {
      # identify long uri i.e. possible DNS exfiltration
      add_tag => "long uri"
    }
  }
  grok {
    match => { "tmp" => "^(?<<http.request.method>.*?) (?<url.full>.*?)( |$)((?<tls.next_protocol>.*?))?(,|)(  ref=(?<http.request.referrer>.*?))?( |)$"}
    tag_on_failure => "_grokparsefailure_url"
  }

  if [event.created] {
    date {
      # "26/aug/2020:19:35:09.533 +0000"
      # ts=[12/oct/2020:17:24:01 +0000]
      match => ["event.created","MMM dd HH:mm:ss","ISO8601","dd/MMM/yyyy:HH:mm:ss ZZ"  ]
      timezone => "GMT"
      locale => "en"
      target => "event.created"
      tag_on_failure => "_dateparsefailure_ec"
    }
    if "_dateparsefailure" in [tags]  {
        if ![log.original] {
      mutate {
          copy => { "message" => "log.original" }
        }
      }
      mutate {
        remove_field => ["event.created"]
      }
    }
  }

  mutate {
    remove_field => [ "pri", "tmp"]
  } 

  translate {
    field => "[rule.id]"
    destination => "[event.action]"
    dictionary => {
      "0" => "Allowed"
      "1" => "Internal error"
      "2" => "Default message template being used for an action"
      "3" => "Internal URL filter error"
      "10" => "Blocked due to an entry in the URL filter database"
      "14" => "Blocked according to URL filtering by expression"
      "15" => "Blocked by the Real-Time Classifier"
      "20" => "Blocked due to lack of content type"
      "22" => "Blocked due to the media type"
      "30" => "Blocked due to a multi-part archive having been found"
      "35" => "Blocked due to an archive not handled by the Archive Handler"
      "80" => "Blocked due to a virus having been found"
      "81" => "Blocked due to unauthorized access"
      "82" => "Blocked due to a bad request"
      "85" => "Blocked due to an internal anti-malware error"
      "92" => "Blocked due to expiration of a certificate"
      "93" => "Blocked due to a revoked certificate"
      "94" => "Blocked due to a forbidden certificate authority (CA)"
      "95" => "Blocked due to an unknown certificate authority (CA)"
      "97" => "Blocked due to a self-signed certificate"
      "98" => "Blocked due to a common name mismatch"
      "102" => "Blocked due to an unspecified certificate incident"
      "103" => "Blocked due to CONNECT not allowed"
      "104" => "Blocked due to the reverse proxy destination not being allowed"
      "140" => "Blocked due to an internal DLP filter error"
      "150" => "Blocked due to an internal Application Control filter error"
      "151" => "Blocked due to a request belonging to an application that is not allowed"
      "160" => "Blocked due to missing policy for Web Hybrid"
      "161" => "Blocked due to web access not being allowed by Web Hybrid"
      "162" => "Blocked due to URL filtering by Web Hybrid"
      "200" => "Blocked due to the coaching session of a user having been exceeded"
      "201" => "Blocked due to the time quota session of a user having been exceeded"
      "202" => "Blocked due to the time quota for a user having been exceeded"
      "203" => "Blocked due to the volume quota session of a user having been exceeded"
      "204" => "Blocked due to the volume quota for a user having been exceeded"
      "205" => "Blocked due to the authorized override session of a user having been exceeded"
      "206" => "Blocked due to the blocking session of a user being active"
      "300" => "Blocked due to a quota redirect"
      "301" => "Blocked due to an authentication redirect"
      "400" => "Blocked due to an authorized override redirect"
    } 
    fallback => "Others"
  } 
  
}
output {
  pipeline { send_to => [enrichments] }
}