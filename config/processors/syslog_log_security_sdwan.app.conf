# Copyright [2021] [Cargill, Incorporated.] 
# SPDX-License-Identifier: Apache-2.0
input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}

filter {
  mutate {
    add_field => { "[event][module]" => "versa" }
    add_field => { "[event][dataset]" => "versa.sdwan_application" }
  }
  # 1. initial parsing

  # a) start by copying the original message to log.original.  
  # this needs to be done in two separate mutate steps in logstash > 8
  # also, on logstash 8 / ecs 8 , as soon as you touch the message the original event is copied to event.original, so log.original and event.original are redundant. 
  # both are kept for compatibility. this should be addressed by a later enrichment
  mutate {
    add_field => {"[log][original]" => "%{[message]}"}
  }
  mutate {
    lowercase => ["[message]"]
  }
  
  grok {
    tag_on_failure => "_parsefailure_header"
    match => { "message" => "(^(.*?)(<(?<pri>\d+)>)(\s)?(?<[actual_msg]>.*$))|(^(?<[actual_msg]>.*)$)" }
    timeout_millis => 500
  }
  syslog_pri {
    syslog_pri_field_name => "pri" 
    remove_field => ["pri"]
  }
  
  # b) we'll then pick the common fields and placing them under [@metadata][tmp]. [@metadata][tmp] is a temporary slot to work out the parsing
  dissect {
    id => "sdwan.app-dissect"
    tag_on_failure => "_dissect_error-sdwan.app-message"
    mapping => {
    "[actual_msg]" => "%{} %{[@metadata][tmp][host]} %{[@metadata][tmp][time]} %{[@metadata][tmp][dataset]}, %{[@metadata][tmp][rest_msg]}"
    }
  }

  # 2. convert the timestamp found in [@metadata][tmp][time]. this is the time the log was generated as per versa
  date {
    id => "sdwan.app-date"
    tag_on_failure => "_dateparsefailure_error_sdwan.app-date"
    match => [ "[@metadata][tmp][time]", "MMM dd yyyy HH:mm:ss",
    "MMM  d yyyy HH:mm:ss", "ISO8601" ]
  }

  # 3. extract the host provided in the beggining of the message, if it exists. move it to [observer][hostname]
  grok {
    id => "sdwan.app-grok"
    tag_on_failure => "_grokparsefailure_error_sdwan.app"
    match => { "[@metadata][tmp][host]" => "{name=%{GREEDYDATA:[observer][hostname]}}" }
  }

  # remove domain from observer hostname if it exists
  mutate {
    gsub => [
        "[observer][hostname]", "(.*?)\.(.*)", "\1"
    ]
  }

  # 4. parse the sdwan module that generated the logs
  mutate {
    id => "sdwan.app-mutate-provider"
    tag_on_failure => "_mutate_error-sdwan.app-provider"
    add_field => { "[event][provider]" => "%{[[event][dataset]]}.%{[[@metadata][tmp][dataset]]}"}
  }

  # 5. take the rest of the sdwan message, which is comprised of field=value split by comma. throw in [@metadata][tmp][rest_msg]
  kv {
    id => "sdwan.app-kv-restmsg"
    tag_on_failure => "_kv_error-sdwan.app-restmsg"
    source => "[@metadata][tmp][rest_msg]"
    field_split => "="
    field_split_pattern => ", "
    target => "[@metadata][tmp][rest_msg]"
    # whitespace => "strict" #check later
  }

  # 6. event categorization

  # a. event kind (alert, event, metric, state, pipeline_error, signal). this filter translate all possible types of versa datasets into the kind field
  translate {
    id => "sdwan.app-translate-eventkind"
    source => "[@metadata][tmp][dataset]"
    target => "[event][kind]"
    dictionary => {
    "alarmlog" => "alert"
    "accesslog" => "state"
    "sfwaccesslog" => "state"
    "denylog" => "state"
    "idplog" => "alert"
    "avlog" => "alert"
    "ipflog" => "alert"
    "urlflog" => "alert"
    "dosthreatlog" => "alert"
    "flowidlog" => "state"
    "flowmonlog" => "state"
    "flowmonhttplog" => "state"
    "monstatslog" => "metric"
    "bwmonlog" => "metric"
    "intfutillog" => "metric"
    "sdwanb2bslamlog" => "metric"
    "tcpappmonlog" => "metric"
    "systemloadlog" => "metric"
    "eventlog" => "event"
  }
    fallback => "event"
  }

  # 7. each event.dataset will require its own parsing since the contents of [@metadata][tmp][rest_msg] will be specific to that dataset.

  # a. alarm logs

  if [@metadata][tmp][dataset] == "alarmlog" {

    mutate {
      add_field => { "[event][reason]" => "unknown" }
    }

    mutate {
      rename => { "[@metadata][tmp][rest_msg][appliancename]" => "[host][hostname]" } # the appliance sending logs is not the appliance where the event took place. this is provided by appliancename
      rename => { "[@metadata][tmp][rest_msg][tenantname]" => "[organization][name]"}
      rename => { "[@metadata][tmp][rest_msg][alarmtype]" => "[error][type]"}
      rename => { "[@metadata][tmp][rest_msg][alarmseqno]" => "[event][sequence]"}
      rename => { "[@metadata][tmp][rest_msg][alarmtext]" => "[error][message]"}
      rename => { "[@metadata][tmp][rest_msg][serialnum]" => "[host][id]"}
      rename => { "[@metadata][tmp][rest_msg][alarmeventtype]" => "[error][code]"}
      update => { "[event][reason]" => "%{[@metadata][tmp][rest_msg][alarmcause]}"}
      tag_on_failure => "_mutate_error_alarmlog"
    }

    mutate {
      rename => {"[tags]" => "[@metadata][tmp][original_tags]"}
    }

    mutate {
      add_tag => [
        "sdwan_alarm_class=%{[@metadata][tmp][rest_msg][alarmclass]}", 
        "sdwan_alarm_kind=%{[@metadata][tmp][rest_msg][alarmkind]}", 
        "sdwan_alarm_severity=%{[@metadata][tmp][rest_msg][alarmseverity]}",
        "sdwan_alarm_key=%{[@metadata][tmp][rest_msg][alarmkey]}",
        "sdwan_alarm_cause=%{[@metadata][tmp][rest_msg][alarmcause]}",
        "sdwan_alarm_onwer=%{[@metadata][tmp][rest_msg][alarmowner]}"
        ]
    }

    mutate {
      rename => {"[tags]" => "[labels][all]"}
    }
    mutate {
      rename => {"[@metadata][tmp][original_tags]" => "[tags]"}
    }
      
    date {
      match => [ "[@metadata][tmp][rest_msg][generatetime]", "UNIX" ]
      target => "[event][start]"
    }

    translate {
      source => "[event][action]"
      target => "[event][outcome]"
      dictionary => {
        "performancedegradeed" => "failure"
        "outofservice" => "failure"
        "thresholdcrossed" => "failure"
      }
      fallback => "unknown"
    }

    # a.1. evaluate inside alarmlogs
    if [error][type] == "sdwan-datapath-sla-not-met"
    {
        dissect {
          mapping => {
          "[@metadata][tmp][rest_msg][alarmkey]" => "%{[rule][name]}|%{[@metadata][tmp][related_src]}|%{[observer][egress][interface][alias]}|%{[@metadata][tmp][related_dst]}|%{[observer][egress][interface][alias]}|%{[@metadata][tmp][cos]}"
          }
        }
        mutate {
          add_field => { "[related][hosts]" => "%{[@metadata][tmp][related_src]}"}
          add_field => { "[source][domain]" => "%{[@metadata][tmp][related_src]}"}
          add_field => { "[destination][domain]" => "%{[@metadata][tmp][related_dst]}"}
          add_field => { "[related][hosts]" => "%{[@metadata][tmp][related_dst]}"}
          add_field => { "[rule][category]" => "%{[error][type]}" }
          
        }

        mutate {update => {"[labels]" => "%{[labels]}&&&network_cos=%{[@metadata][tmp][cos]}"}}

    }

    # a.2. evaluate inside alarmlogs
    else if [error][type] == "lef-collector-queue-utilization"
    {
      grok {
        match => { "[error][message]" => "%{GREEDYDATA:[@metadata][tmp][lefcollectorqueueutilization]}queue %{NOTSPACE:[@metadata][tmp][queue]} %{GREEDYDATA:[@metadata][tmp][action]} \(%{WORD:[@metadata][tmp][paramname]}: %{NOTSPACE:[@metadata][tmp][paramvalue]}\)"  }
      }
      mutate {update => {"[labels]" => "%{[labels]}&&&sdwan_queue=%{[@metadata][tmp][queue]"}}
      mutate {update => {"[labels]" => "%{[labels]}&&&%{[@metadata][tmp][paramname]}=%{[@metadata][tmp][paramvalue]"}}
      
    }

    # a.3. evaluate inside alarmlogs
    else if [error][type] == "cgnat-pool-utilization"
    {
      grok {
        match => { "[error][message]" => "%{GREEDYDATA}\(%{GREEDYDATA:[@metadata][tmp][paramname]}: %{NOTSPACE:[@metadata][tmp][paramvalue]}\)"}
      }
      mutate {
        update => {"[labels]" => "%{[labels]&&&%{[@metadata][tmp][paramname]}=%{[@metadata][tmp][paramvalue]}"}
        
      }
    }

    # rfc 5424 translation. see https://datatracker.ietf.org/doc/html/rfc5424#appendix-a.3 on why we do this
    translate {
      source => "[@metadata][tmp][rest_msg][alarmseverity]"
      target => "[log][syslog][severity][name]"
      dictionary => {
        "warning" => "warning"
        "indeterminate" => "informational"
        "minor" => "notice"
        "major" => "error"
        "critical" => "critical"
        "cleared" => "informational"
      }
      fallback => "debug"
    }

    translate {
      source => "[@metadata][tmp][rest_msg][alarmseverity]"
      target => "[log][syslog][severity][code]"
      dictionary => {
        "warning" => 4
        "indeterminate" => 6
        "minor" => 5
        "major" => 3
        "critical" => 2
        "cleared" => 6
      }
      fallback => 7
    }

  }

  # b. sdwanb2bslamlog
  if [@metadata][tmp][dataset] == "sdwanb2bslamlog" {
    mutate {
      rename => { "[@metadata][tmp][rest_msg][appliancename]" => "[host][hostname]" }
      rename => { "[@metadata][tmp][rest_msg][tenantname]" => "[organization][name]"}
      add_field => { "[related][hosts]" => "%{[@metadata][tmp][rest_msg][localsitename]}"}
      add_field => { "[related][hosts]" => "%{[@metadata][tmp][rest_msg][remotesitename]}"}
      add_field => { "[observer][ingress][interface][name]" => "%{[@metadata][tmp][rest_msg][remoteacccktname]}"}
      add_field => { "[observer][egress][interface][name]" => "%{[@metadata][tmp][rest_msg][localacccktname]}"}
      add_field => { "[network][direction]" => "outbound"}
      update => { "[labels]" => "%{[labels]}&&&network_cos=%{[@metadata][tmp][rest_msg][fwdclass]}"}
    }
    
  }

  # c. systemloadlogs
  if [@metadata][tmp][dataset] == "systemloadlog" {
    mutate {
      rename => {"[@metadata][tmp][rest_msg][cpuload]" => "[host][cpu][usage]"}
      rename => {"[@metadata][tmp][rest_msg][memload]" => "[host][memory][usage]"} 
    }
  }

  # d. eventlogs
  if [@metadata][tmp][dataset] == "eventlog" {

    mutate {
      rename => {"[tags]" => "[@metadata][tmp][original_tags]"}
    }

    mutate {
      id => "sdwan.app-mutate-eventlog"
      tag_on_failure => "_mutate_error-sdwan.app-eventlog"
      rename => { "[@metadata][tmp][rest_msg][appliancename]" => "[host][hostname]" }
      rename => { "[@metadata][tmp][rest_msg][tenantname]" => "[organization][name]"}
      rename => { "[@metadata][tmp][rest_msg][eventtype]" => "[error][type]"}
      rename => { "[@metadata][tmp][rest_msg][rule]" => "[network][application]"}
      add_field => {"[related][hosts]" => "%{[@metadata][tmp][rest_msg][localsitename]}"}
      add_field => {"[related][hosts]" => "%{[@metadata][tmp][rest_msg][remotesitename]}"}
      add_field => { "[observer][ingress][interface][name]" => "%{[@metadata][tmp][rest_msg][remoteacccktname]}"}
      add_field => { "[observer][egress][interface][name]" => "%{[@metadata][tmp][rest_msg][localacccktname]}"}
      
    }

    mutate {
      add_tag => [
        "network_cos=%{[@metadata][tmp][rest_msg][fwdclass]}"
        ]
    }

    date {
      match => [ "[@metadata][tmp][rest_msg][generatetime]", "UNIX" ]
      target => "[event][start]"
    }

    # b.1. evaluate inside alarmlogs
    if [error][type] == "sdwan-datapath-sla-not-met"
    {
      dissect {
        mapping => {
        "[@metadata][tmp][rest_msg][alarmkey]" => "%{[network][application]}|%{[related][hosts]}|%{[observer][egress][interface][alias]}|%{[related][hosts]}|%{[observer][ingress][interface][name]}|%{[@metadata][tmp][cos]}"
        }
      }

      mutate {
        add_tag => ["network_cos=%{[@metadata][tmp][cos]}"]
      }
    }

    mutate {
      rename => {"[tags]" => "[labels][all]"}
    }
    mutate {
      rename => {"[@metadata][tmp][original_tags]" => "[tags]"}
    }
  }

    # ...
    # q. tcp app mon logs

  # 8. Handle specific error types

  # parse cpu threshold cross for cpu-utilization error-type
  if [error][type] == "cpu-utilization" {
    grok {
        match => { "[error][message]" => "%{NUMBER:[@metadata][tmp][cpu_usage]}" }
      }
    mutate {
      add_field => {"[host][cpu][usage]" => "0.%{[@metadata][tmp][cpu_usage]}"}
    }
    mutate {
        convert => {
          "[host][cpu][usage]" => "float"
        }
      }
  }

  # 9. convert fields (i.e. extract site, appliance type, etc)
  if [host.hostname] {
    if "" in [network][name] or ![network][name]  {
      mutate {
          add_field => {"[network][name]" => "%{[host][hostname]}" }
      }
    }

    mutate {
      gsub => [
          "[service][type]", "(.*)-([a-z]*)", "\2",
          "[network][name]", "([a-z]*)([0-9].*)", "\1"
      ]
    }

    mutate {
      gsub => [
          "[service][type]", "(.*)-([a-z]*)", "\2",
          "[network][name]", "([a-z]*)([0-9].*)", "\1"
      ]
    }
  }

  # 10. drop unwanted fields

  mutate {
    remove_field => [
      "actual_msg",
      
    ]
  }

}

output {
  pipeline { send_to => [enrichments] }
}
