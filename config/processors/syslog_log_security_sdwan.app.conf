# Copyright [2021] [Cargill, Incorporated.] 
# SPDX-License-Identifier: Apache-2.0
input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}
<<<<<<< HEAD




=======
>>>>>>> upstream/master
filter {
  mutate {
    add_field => { "event.module" => "sdwan.application" }
    add_field => { "observer.vendor" => "versa" }
    add_field => { "observer.product" => "versa.sdwan.application" }
    add_field => { "observer.type" => "network_management" }
<<<<<<< HEAD
  }
    
  # 1. start by copying the original message to log.original.  we'll then pick the common fields and placing them under [tmp]. [tmp] is a temporary slot to work out the parsing

  mutate {
    id => "sdwan.app-mutate-logoriginal"
    tag_on_failure => "_mutate_error-sdwan.app-logoriginal"
    add_field => {"[log.original]" => "%{[message]}"}
    lowercase => ["[message]"]
  }

  dissect {
    id => "sdwan.app-dissect"
    tag_on_failure => "_dissect_error-sdwan.app-message"
    mapping => {
    "message" => "%{} %{[tmp][host]} %{[tmp][time]} %{[tmp][dataset]}, %{[tmp][rest_msg]}"
    }
  }

  # 2. convert the timestamp and place that into [tmp][time]
  date {
    id => "sdwan.app-date"
    tag_on_failure => "_dateparsefailure_error_sdwan.app-date"
    match => [ "[tmp][time]", "MMM dd yyyy HH:mm:ss",
    "MMM  d yyyy HH:mm:ss", "ISO8601" ]
  }

  # 3. extract the host prodvided in the beggining of the message. move it to observer.hostname
  grok {
    id => "sdwan.app-grok"
    tag_on_failure => "_grokparsefailure_error_sdwan.app"
    match => { "[tmp][host]" => "{name=%{GREEDYDATA:observer.hostname}}" }
  }

  # 4. parse the sdwan module that generated the logs
  mutate {
    id => "sdwan.app-mutate-dataset"
    tag_on_failure => "_mutate_error-sdwan.app-dataset"
    add_field => { "[event.dataset]" => "%{event.module}.%{[tmp][dataset]}"}
  }

  # 5. take the rest of the sdwan message, which is comprised of field=value split by comma. throw in [tmp][rest_msg]
  kv {
    id => "sdwan.app-kv-restmsg"
    tag_on_failure => "_kv_error-sdwan.app-restmsg"
    source => "[tmp][rest_msg]"
    field_split => "="
    field_split_pattern => ", "
    target => "[tmp][rest_msg]"
    # whitespace => "strict" #check later
  }

  # 6. event categorization

  # a. event kind (alert, event, metric, state, pipeline_error, signal)
  translate {
    id => "sdwan.app-translate-eventkind"
    field => "[tmp][dataset]"
    destination => "[event.kind]"
    dictionary => {
    "alarmlog" => "alert"
    "accesslog" => "state"
    "sfwaccesslog" => "state"
    "denylog" => "state"
    "idplog" => "alert"
    "avlog" => "alert"
    "ipflog" => "alert"
    "urlflog" => "alert"
    "dosthreatlog" => "alert"
    "flowidlog" => "state"
    "flowmonlog" => "state"
    "flowmonhttplog" => "state"
    "monstatslog" => "metric"
    "bwmonlog" => "metric"
    "intfutillog" => "metric"
    "sdwanb2bslamlog" => "metric"
    "tcpappmonlog" => "metric"
    "systemloadlog" => "metric"
    "eventlog" => "event"
  }
    fallback => "event"
  }

  # 7. each event.dataset will require its own parsing since the contents of [tmp][rest_msg] will be specific to that dataset.

    # a. alarm logs

    if [tmp][dataset] == "alarmlog" {
      mutate {
        rename => { "[tmp][rest_msg][appliancename]" => "host.hostname" }
        rename => { "[tmp][rest_msg][tenantname]" => "organization.name"}
        rename => { "[tmp][rest_msg][alarmtype]" => "error.type"}
        rename => { "[tmp][rest_msg][alarmcause]" => "event.action"}
        rename => { "[tmp][rest_msg][alarmseqno]" => "event.id"}
        rename => { "[tmp][rest_msg][alarmtext]" => "error.message"}
        rename => { "[tmp][rest_msg][serialnum]" => "host.id"}
        add_field => {"[labels][alarm_class]" => "%{[tmp][rest_msg][alarmclass]}"}
        add_field => {"[labels][alarm_kind]" => "%{[tmp][rest_msg][alarmkind]}"}
        add_field => {"[labels][alarm_event_type]" => "%{[tmp][rest_msg][alarmeventtype]}"}
        add_field => {"[labels][alarm_cause]" => "%{event.action}"}
        add_field => {"[labels][alarm_severity]" => "%{[tmp][rest_msg][alarmseverity]}"}
        add_field => {"[labels][alarm_key]" => "%{[tmp][rest_msg][alarmkey]}"}
        
      }
      date {
        match => [ "[tmp][rest_msg][generatetime]", "UNIX" ]
        target => "event.start"
      }

      translate {
        field => "event.action"
        destination => "event.outcome"
        dictionary => {
          "performancedegradeed" => "failure"
          "outofservice" => "failure"
        }
        fallback => "unknown"
      }

      if [error.type] == "sdwan-datapath-sla-not-met"
      {
          dissect {
            mapping => {
            "[tmp][rest_msg][alarmkey]" => "%{rule.name}|%{[tmp][related_src]}|%{observer.egress.interface.alias}|%{[tmp][related_dst]}|%{observer.ingress.interface.name}|%{[labels][cos]}"
            }
          }
          mutate {
            add_field => { "related.hosts" => "%{[tmp][related_src]}"}
            add_field => { "source.domain" => "%{[tmp][related_src]}"}
            add_field => { "destination.domain" => "%{[tmp][related_dst]}"}
            add_field => { "related.hosts" => "%{[tmp][related_dst]}"}
            add_field => { "rule.category" => "%{error.type}" }
          }

      }


      if [error.type] == "lef-collector-queue-utilization"
      {
        grok {
          match => { "error.message" => "%{GREEDYDATA:[tmp][lefcollectorqueueutilization]}queue %{NOTSPACE:[labels][queue]} %{GREEDYDATA:[tmp][action]} \(%{WORD:[tmp][paramname]}: %{NOTSPACE:[tmp][paramvalue]}\)"  }
        }
        mutate {
          add_field => { "[labels][%{[tmp][paramname]}]" => "%{[tmp][paramvalue]}" }
          
        }
      }

      if [error.type] == "cgnat-pool-utilization"
      {
        grok {
          match => { "error.message" => "%{GREEDYDATA}\(%{GREEDYDATA:[tmp][paramname]}: %{NOTSPACE:[tmp][paramvalue]}\)"}
        }
        mutate {
          add_field => { "[labels][%{[tmp][paramname]}]" => "%{[tmp][paramvalue]}" }
        }
      }

    # rfc 5424 translation. see https://datatracker.ietf.org/doc/html/rfc5424#appendix-a.3 on why we do this
    translate {
      field => "[tmp][rest_msg][alarmseverity]"
      destination => "log.syslog.severity.name"
      dictionary => {
        "warning" => "warning"
        "indeterminate" => "informational"
        "minor" => "notice"
        "major" => "error"
        "critical" => "critical"
        "cleared" => "informational"
      }
      fallback => "debug"
    }

    translate {
      field => "[tmp][rest_msg][alarmseverity]"
      destination => "log.syslog.severity.code"
      dictionary => {
        "warning" => 4
        "indeterminate" => 6
        "minor" => 5
        "major" => 3
        "critical" => 2
        "cleared" => 6
      }
      fallback => 7
    }


    }

    # b. sdwanb2bslamlog

    if [tmp][dataset] == "sdwanb2bslamlog" {
      mutate {
        rename => { "[tmp][rest_msg][appliancename]" => "host.hostname" }
        rename => { "[tmp][rest_msg][tenantname]" => "organization.name"}
        add_field => { "related.hosts" => "%{[tmp][rest_msg][localsitename]}"}
        add_field => { "related.hosts" => "%{[tmp][rest_msg][remotesitename]}"}
        add_field => { "observer.ingress.interface.name" => "%{[tmp][rest_msg][remoteacccktname]}"}
        add_field => { "observer.egress.interface.name" => "%{[tmp][rest_msg][localacccktname]}"}
        add_field => { "network.direction" => "outbound"}
        add_field => { "[labels][cos]" => "%{[tmp][rest_msg][fwdclass]}"} #fwd class is not actually an application, it is a network cos queue, but that's the closest ecs has.

      }
      
    }

    # c. systemloadlogs

    if [tmp][dataset] == "systemloadlog" {
      mutate {
        rename => {"[tmp][rest_msg][cpuload]" => "host.cpu.usage"}
        rename => {"[tmp][rest_msg][memload]" => "host.memory.usage"} #host.memory.usage does not exist in ecs 1.9
      }
    }

    # d. eventlogs

    if [tmp][dataset] == "eventlog" {
      mutate {
        id => "sdwan.app-mutate-eventlog"
        tag_on_failure => "_mutate_error-sdwan.app-eventlog"
        rename => { "[tmp][rest_msg][appliancename]" => "host.hostname" }
        rename => { "[tmp][rest_msg][tenantname]" => "organization.name"}
        rename => { "[tmp][rest_msg][eventtype]" => "error.type"}
        rename => { "[tmp][rest_msg][rule]" => "network.application"}
        add_field => {"[related.hosts]" => "%{[tmp][rest_msg][localsitename]}"}
        add_field => {"[related.hosts]" => "%{[tmp][rest_msg][remotesitename]}"}
        add_field => { "observer.ingress.interface.name" => "%{[tmp][rest_msg][remoteacccktname]}"}
        add_field => { "observer.egress.interface.name" => "%{[tmp][rest_msg][localacccktname]}"}
        add_field => { "[labels][cos]" => "%{[tmp][rest_msg][fwdclass]}"} #fwd class is not actually an application, it is a network cos queue, but that's the closest ecs has.

      }
      date {
        match => [ "[tmp][rest_msg][generatetime]", "UNIX" ]
        target => "event.start"
      }

      if [error.type] == "sdwan-datapath-sla-not-met"
      {
          dissect {
            mapping => {
            "[tmp][rest_msg][alarmkey]" => "%{network.application}|%{related.hosts}|%{observer.egress.interface.alias}|%{related.hosts}|%{observer.ingress.interface.name}|%{[labels][cos]}"
            }
          }

      }
    }

    
  

    # ...
    # q. tcp app mon logs

  # 8. convert fields (i.e. extract site, appliance type, etc)
  if [host.hostname] {
    if "" in [network.name] or ![network.name]  {
      mutate {
          add_field => {"[network.name]" => "%{[host.hostname]}" }
      }
    }


  mutate {
      gsub => [
          "[service.type]", "(.*)-([a-z]*)", "\2",
          "[network.name]", "([a-z]*)([0-9].*)", "\1"
      ]
  }
=======
    }
    ### Header
  ### Logstash tcp or udp in
  if [agent.type] == "logstash" {
    dissect {
      tag_on_failure => "_dateparsefailure_header"
        mapping => {
            message => "<%{pri}> %{rest_msg}"
        }
    }
  } else {
  ### Filebeats udp or tcp in
    dissect {
      tag_on_failure => "_dateparsefailure_header"
        mapping => {
            message => "%{?data} {%{?data}} <%{pri}> %{rest_msg}"
        }
    }
  }
  syslog_pri {
    syslog_pri_field_name => "pri"
  }
  mutate{
    remove_field => ["pri"]
  }
    # 1. Start by copying the original message to log.original.  We'll then pick the common fields and placing them under [tmp]. [tmp] is a temporary slot to work out the parsing

    mutate {
        add_field => {"[log.original]" => "%{[message]}"}
    }

    dissect {
        mapping => {
        "message" => "%{} %{[tmp][host]} %{[tmp][time]} %{[tmp][module]}, %{[tmp][rest_msg]}"
        }
    }

    # 2. Convert the timestamp and place that into [tmp][time]
    date {
        match => [ "[tmp][time]", "MMM dd yyyy HH:mm:ss",
              "MMM  d yyyy HH:mm:ss", "ISO8601" ]
    }

    # 3. Extract the host prodvided in the beggining of the message. Move it to log.source.hostname
    grok {
        match => { "[tmp][host]" => "{name=%{GREEDYDATA:log.source.hostname}}" }
    }

    # 4. Parse the SDWAN module that generated the logs
    mutate {
      add_field => { "[event_kind]" => "%{[tmp][module]}"}
    }

    # 5. Take the rest of the SDWAN message, which is comprised of field=value split by comma. Throw in [tmp][rest_msg]
    kv {
        source => "[tmp][rest_msg]"
        field_split => "="
        field_split_pattern => ", "
        target => "tmp"
       # whitespace => "strict" #check later
    }

    # 6. We end up with all SDWAN specific fields from rest msg. Now use 3 mutate s (for readability) to perform 3 actions below

        #a) Parse fields that belong to ECS into ECS fields
    mutate {
        rename => { "[tmp][alarmSeverity]" => "log.syslog.severity.name" }
        rename => { "[tmp][applianceName]" => "host.hostname"}
        rename => { "[tmp][alarmType]" => "event.action" }
        rename => { "[tmp][alarmCause]" => "event.dataset"} # check later
        rename => { "[tmp][alarmSeqNo]" => "error.id"}
        rename => { "[tmp][alarmEventType]" => "error.type"}
        rename => { "[tmp][alarmText]" => "error.message"}
        rename => { "[tmp][alarmClass]" => "rule.category"}
        rename => { "[tmp][serialNum]" => "host.id"}
        rename => { "[tmp][siteName]" => "network.name"}
        rename => { "[tmp][alarmKind]" => "event.reason"}
    }

        # b) Parse fields that don't belong to ECS into Labels (as per https://www.elastic.co/guide/en/ecs/current/ecs-custom-fields-in-ecs.html#_the_labels_field)
        # mutate {
        # rename => { "[tmp][alarmKey]" => "[labels][alarmKey]"}
        # }

        # c) Drop unused/unwanted fields
    mutate {
        remove_field => [ "[tmp]" ]
    }

    #7. Proceed to hardcoded evaluations

    # event kind (alert, event, metric, state, pipeline_error, signal)
    translate {
        field => "[event_kind]"
        destination => "[event.kind]"
        dictionary => {
          "alarmLog" => "alert"
          "accessLog" => "state"
          "sfwAccessLog" => "state"
          "denyLog" => "state"
          "idpLog" => "alert"
          "avLog" => "alert"
          "ipfLog" => "alert"
          "urlfLog" => "alert"
          "dosThreatLog" => "alert"
          "flowIdLog" => "state"
          "flowMonLog" => "state"
          "flowMonHttpLog" => "state"
          "monStatsLog" => "metric"
          "bwMonLog" => "metric"
          "intfUtilLog" => "metric"
          "sdwanB2BSlamLog" => "metric"
          "tcpAppMonLog" => "metric"
        }
        fallback => "event"
    }

    # event category
    translate {
        field => "[error.type]"
        destination => "[event.category]"
        dictionary => {
          "equipmentAlarm" => "host"
        }
    }

    # event type
    translate {
        field => "[event.action]"
        destination => "[event.type]"
        dictionary => {
          "interface-down" => "error"
          "interface-up" => "info"
        }
    }

    # event outcome
    translate {
        field => "[event.dataset]"
        destination => "[event.outcome]"
        dictionary => {
          "outOfService" => "failure"
        }
    }

    # 8. Convert fields (i.e. extract site, appliance type, etc)
    if "" in [network.name] or ![network.name]  {
        mutate {
            add_field => {"[network.name]" => "%{[host.hostname]}" }
        }
    }

    mutate {
        add_field => {"[service.type]" => "%{[host.hostname]}"}
    }

>>>>>>> upstream/master

    mutate {
        gsub => [
            "[service.type]", "(.*)-([a-z]*)", "\2",
            "[network.name]", "([a-z]*)([0-9].*)", "\1"
        ]
    }
<<<<<<< HEAD
  }

  
  # 9. drop unwanted fields
  mutate{
    remove_field => ["rest_msg", "event_kind", "tmp"]
  }

}

=======
    mutate{
      remove_field => ["rest_msg", "event_kind"]
    }
}
>>>>>>> upstream/master
output {
  pipeline { send_to => [enrichments] }
}
