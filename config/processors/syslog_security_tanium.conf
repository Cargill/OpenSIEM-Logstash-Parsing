# Copyright [2021] [Cargill, Incorporated.] 
# SPDX-License-Identifier: Apache-2.0
input {
  pipeline {
    address => VAR_PIPELINE_NAME
  }
}
filter {
  mutate {
    add_field => { "[event][module]" => "tanium" }
    add_field => { "[event][dataset]" => "tanium.events" }
  }
  if [message] =~ "^{.*?" {
    grok {
      tag_on_failure => "_parsefailure_header1"
      match => { "message" => "^(?<rest_msg>.*?)$" }
      timeout_millis => 500
    }
  }
  else {
    grok {
      tag_on_failure => "_parsefailure_header2"
      match => { "message" => "^(.*? \{.*?} )?(?<rest_msg>.*?)$" }
      timeout_millis => 500
    }
  }
  json {
    source => "rest_msg"
    skip_on_invalid_json => true
    target => "tanm"
  }
  if [tanm][Intel Type] == "tanium-signal" or [tanm][Intel Type] == "reputation" {
   mutate {
    copy => { "[tanm][Intel Type]" => "[event][type]" } 
    rename => {"[tanm][Alert Id]" => "[event][id]" }
    rename => {"[tanm][Timestamp]" => "[event][created]" }
    rename => {"[tanm][Computer Name]" => "[host][hostname]" }
    rename => {"[tanm][Computer IP]" => "[source][ip]" }
    rename => {"[tanm][Intel Id]" => "[event][id]" }
    # rename => {"[tanm][Intel Type]" => "[intel][type]" } ### change
    rename => {"[tanm][Intel Name]" => "[rule][name]" }
    rename => {"[tanm][Intel Labels]" => "[intel][label]" }
    rename => {"[tanm][MITRE Techniques]" => "[threat][technique][id]" }
    rename => {"[tanm][Match Details][system_info][bits]" => "[host][architecture]" }
    rename => {"[tanm][Match Details][system_info][os]" => "[host][os][name]" }
    rename => {"[tanm][Match Details][system_info][platform]" => "[host][os][family]" }
    rename => {"[tanm][Match Details][system_info][patch_level]" => "[host][os][version]" }
     
    rename => {"[tanm][Match Details][match][properties][args]" => "[process][args]" }
    rename => {"[tanm][Match Details][match][properties][file][fullpath]" => "[process][executable]" }
    rename => {"[tanm][Match Details][match][properties][file][md5]" => "[process][hash][md5]" }
    rename => {"[tanm][Match Details][match][properties][file][sha1]" => "[process][hash][sha1]" }
    rename => {"[tanm][Match Details][match][properties][file][sha256]" => "[process][hash][sha256]" }
    
    rename => {"[tanm][Match Details][match][properties][fullpath]" => "[process][executable]" }
    rename => {"[tanm][Match Details][match][properties][md5]" => "[process][hash][md5]" }
    rename => {"[tanm][Match Details][match][properties][sha1]" => "[process][hash][sha1]" }
    rename => {"[tanm][Match Details][match][properties][sha256]" => "[process][hash][sha256]" }
    rename => {"[tanm][Match Details][match][properties][size]" => "[file][size]" }
    
    
    # rename => {"[tanm][match][Match Details][properties][file][size]" =>  "" }
    rename => {"[tanm][Match Details][match][properties][parent][args]" => "[process][parent][args]" }
    rename => {"[tanm][Match Details][match][properties][parent][user]" => "[user][tmp]" }
    rename => {"[tanm][Match Details][match][properties][parent][file][fullpath]" => "[process][parent][executable]" }
    rename => {"[tanm][Match Details][match][properties][parent][file][md5]" => "[process][parent][hash][md5]" }
    rename => {"[tanm][Match Details][match][properties][parent][file][sha1]" => "[process][parent][hash][sha1]" }
    rename => {"[tanm][Match Details][match][properties][parent][file][sha256]" => "[process][parent][hash][sha256]" }

    split => { "[threat][technique][id]" => "," }
  }
  if [user][tmp] { 
      if [user][tmp] =~ "^.*?\\.*?$" {
        grok {
          match => {
            "[user][tmp]" => '^(?<[tmp][domain]>.*?)\\(?<[tmp][name]>.*?)$'
          }
          tag_on_failure => "_grokparsefailure_user1"
          timeout_millis => 500
        }
        mutate {
          merge => { "[user][domain]" => "[tmp][domain]" }
          merge => { "[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]", "[tmp][domain]", "[tmp][name]"  ]
        }
      } else {
        mutate {
          merge => {"[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]"]
        }
      }
    }
   if [tanm][Match Details][match][properties][parent][parent][args] {
    mutate {
      merge => {"[process][parent][args]" => "[tanm][Match Details][match][properties][parent][parent][args]" }
      rename => {"[tanm][Match Details][match][properties][parent][parent][user]" => "[user][tmp]" }
      merge => {"[process][parent][executable]" => "[tanm][Match Details][match][properties][parent][parent][file][fullpath]" }
      merge => {"[process][parent][hash][md5]" => "[tanm][Match Details][match][properties][parent][parent][parent][file][md5]" }
      merge => {"[process][parent][hash][sha1]" =>  "[tanm][Match Details][match][properties][parent][parent][file][sha1]" }
      merge => {"[process][parent][hash][sha256]" => "[tanm][Match Details][match][properties][parent][parent][file][sha256]" }
    }
    if [user][tmp] { 
      if [user][tmp] =~ "^.*?\\.*?$" {
        grok {
          match => {
            "[user][tmp]" => '^(?<[tmp][domain]>.*?)\\(?<[tmp][name]>.*?)$'
          }
          tag_on_failure => "_grokparsefailure_user2"
          timeout_millis => 500
        }
        mutate {
          merge => { "[user][domain]" => "[tmp][domain]" }
          merge => { "[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]", "[tmp][domain]", "[tmp][name]"  ]
        }
      } else {
        mutate {
          merge => {"[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]"]
        }
      }
    }
  }
  
  if [tanm][Match Details][match][properties][parent][parent][parent][args] {
    mutate {
      merge => {"[process][parent][args]" => "[tanm][Match Details][match][properties][parent][parent][parent][args]" }
      rename => {"[tanm][Match Details][match][properties][parent][parent][parent][user]" => "[user][tmp]" }
      merge => {"[process][parent][executable]" => "[tanm][Match Details][match][properties][parent][parent][parent][file][fullpath]" }
      merge => {"[process][parent][hash][md5]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][file][md5]" }
      merge => {"[process][parent][hash][sha1]" =>  "[tanm][Match Details][match][properties][parent][parent][parent][file][sha1]" }
      merge=> {"[process][parent][hash][sha256]" => "[tanm][Match Details][match][properties][parent][parent][parent][file][sha256]" }
    }
    if [user][tmp] { 
      if [user][tmp] =~ "^.*?\\.*?$" {
        grok {
          match => {
            "[user][tmp]" => '^(?<[tmp][domain]>.*?)\\(?<[tmp][name]>.*?)$'
          }
          tag_on_failure => "_grokparsefailure_user3"
          timeout_millis => 500
        }
        mutate {
          merge => { "[user][domain]" => "[tmp][domain]" }
          merge => { "[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]", "[tmp][domain]", "[tmp][name]"  ]
        }
      } else {
        mutate {
          merge => {"[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]"]
        }
      }
    }
  }
  if [tanm][Match Details][match][properties][parent][parent][parent][parent][args] {
    mutate {
      merge => {"[process][parent][args]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][args]" }
      rename => {"[tanm][Match Details][match][properties][parent][parent][parent][parent][user]"  => "[user][tmp]" }
      merge => {"[process][parent][executable]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][file][fullpath]" }
      merge => {"[process][parent][hash][md5]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][file][md5]" }
      merge => {"[process][parent][hash][sha1]" =>  "[tanm][Match Details][match][properties][parent][parent][parent][parent][file][sha1]" }
      merge=> {"[process][parent][hash][sha256]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][file][sha256]" }
    }
    if [user][tmp] { 
      if [user][tmp] =~ "^.*?\\.*?$" {
        grok {
          match => {
            "[user][tmp]" => '^(?<[tmp][domain]>.*?)\\(?<[tmp][name]>.*?)$'
          }
          tag_on_failure => "_grokparsefailure_user4"
          timeout_millis => 500
        }
        mutate {
          merge => { "[user][domain]" => "[tmp][domain]" }
          merge => { "[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]", "[tmp][domain]", "[tmp][name]"  ]
        }
      } else {
        mutate {
          merge => {"[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]"]
        }
      }
    }
  }
  if [tanm][Match Details][match][properties][parent][parent][parent][parent][parent][args] {
    mutate {
      merge => {"[process][parent][args]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][args]" }
      rename => {"[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][user]"  => "[user][tmp]" }
      merge => {"[process][parent][executable]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][file][fullpath]" }
      merge => {"[process][parent][hash][md5]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][parent][file][md5]" }
      merge => {"[process][parent][hash][sha1]" =>  "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][file][sha1]" }
      merge=> {"[process][parent][hash][sha256]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][file][sha256]" }
    }
    if [user][tmp] { 
      if [user][tmp] =~ "^.*?\\.*?$" {
        grok {
          match => {
            "[user][tmp]" => '^(?<[tmp][domain]>.*?)\\(?<[tmp][name]>.*?)$'
          }
          tag_on_failure => "_grokparsefailure_user5"
          timeout_millis => 500
        }
        mutate {
          merge => { "[user][domain]" => "[tmp][domain]" }
          merge => { "[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]", "[tmp][domain]", "[tmp][name]"  ]
        }
      } else {
        mutate {
          merge => {"[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]"]
        }
      }
    }
  }
  if [tanm][Match Details][match][properties][parent][parent][parent][parent][parent][parent][args] {
    mutate {
      merge => {"[process][parent][args]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][parent][args]" }
      rename => {"[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][parent][user]" => "[user][tmp]" }
      merge => {"[process][parent][executable]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][parent][file][fullpath]" }
      merge => {"[process][parent][hash][md5]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][parent][parent][file][md5]" }
      merge => {"[process][parent][hash][sha1]" =>  "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][parent][file][sha1]" }
      merge=> {"[process][parent][hash][sha256]" => "[tanm][Match Details][match][properties][parent][parent][parent][parent][parent][parent][file][sha256]" }
    }
    if [user][tmp] { 
      if [user][tmp] =~ "^.*?\\.*?$" {
        grok {
          match => {
            "[user][tmp]" => '^(?<[tmp][domain]>.*?)\\(?<[tmp][name]>.*?)$'
          }
          tag_on_failure => "_grokparsefailure_user6"
          timeout_millis => 500
        }
        mutate {
          merge => { "[user][domain]" => "[tmp][domain]" }
          merge => { "[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]", "[tmp][domain]", "[tmp][name]"  ]
        }
      } else {
        mutate {
          merge => {"[user][name]" => "[tmp][name]" }
          remove_field => ["[user][tmp]"]
        }
      }
    }
  }
  } else if [tanm][Intel Type] == "tanium-asset-info" {
    mutate {
      copy => { "[tanm][Intel Type]" => "[event][module]" }
      add_field => { "[observer][vendor]" => "tanium" }
      rename => { "[tanm][Computer Name]" => "[host][hostname]" }
      rename => {"[tanm][Computer IP]" => "[source][ip]" }
      rename => { "[tanm][Operating System]" => "[host][os][name]" }
      rename => { "[tanm][Operating System Install Date]" => "[host][os][installation_date]" }
      rename => { "[tanm][Computer Serial Number]" => "[host][serial]" }
      rename => { "[tanm][Domain Name]" => "[host][domain]" }
      rename => { "[tanm][MAC Address]" => "[host][mac]" }
      rename => { "[tanm][IPv4 Address]" => "[host][ip]" }
      rename => { "[tanm][Tanium Client IP Address]" => "[source][ip]" }
      rename => { "[tanm][Tanium Client NAT IP Address]" => "[source][nat][ip]" }
      rename => { "[tanm][Tanium Server Name]" => "[observer][hostname]" }
      rename => { "[tanm][Logged In Users]" => "[host][logged_in_users]" }
      rename => { "[tanm][Last Logged In User]" => "[host][last_logged_in_user]" }
      rename => { "[tanm][Time Zone]" => "[host][timezone]" }
      rename => { "[tanm][Manufacturer]" => "[host][manufacturer]" } 
      rename => { "[tanm][Model]" => "[host][model]" }
    }
  } else if [tanm][Intel Type] == "openioc" {
    mutate {
      copy => { "[tanm][Intel Type]" => "[event][module]" }
      add_field => { "vulnerability.scanner.vendor" => "tanium" }
      rename => { "[tanm][Timestamp]" => "[event][ingested]" } # "2021-02-22T16:43:27.000Z"
      rename => { "[tanm][Computer Name]" => "[host][hostname]" }
      rename => {"[tanm][Computer IP]" => "[host][ip]" }
      rename => {"[tanm][Intel Id]" => "[event][id]" }
      rename => {"[tanm][Intel Name]" => "[rule][name]" }
      rename => {"[tanm][Intel Labels]" => "[intel][label]" } ### change
      rename => {"[tanm][MITRE Techniques]" => "[threat][technique][id]" }
      
      rename => {"[tanm][Match Details][finding][system_info][bits]" => "[host][architecture]" }
      rename => {"[tanm][Match Details][finding][system_info][os]" => "[host][os][name]" }
      rename => {"[tanm][Match Details][finding][system_info][platform]" => "[host][os][family]" }
      rename => {"[tanm][Match Details][finding][system_info][patch_level]" => "[host][os][version]" }
     
      rename => {"[tanm][Match Details][match][type]" => "[service][type]" }
      rename => {"[tanm][Match Details][match][properties][source]" => "[rule][ruleset]" }
      rename => {"[tanm][Match Details][match][properties][message]" => "[event][original]" }
      rename => {"[tanm][Match Details][match][properties][write_time]" => "[event][start]" } # "2021-02-22T13:26:13Z",
      rename => {"[tanm][Match Details][match][properties][gen_time]" => "[event][end]" } # "2021-02-22T13:26:13Z"   
    }
    if [rule][name] =~ ".*?CVE-\d+-\d+ .*?" {
      grok {
        match => {
          "[rule][name]" => '^.*?(?<vulnerability.id>CVE-\d+-\d+) '
        }
        tag_on_failure => "_grokparsefailure_cve"
        timeout_millis => 500
      }
    }
  } else {
    if [rest_msg] =~ "Custom Tags" {
      json {
        source => "rest_msg"
        skip_on_invalid_json => true
        target => "notag"
      }
      mutate {
        rename => {"[notag][Computer Name]" => "[host][hostname]" }
        rename => {"[notag][Custom Tags]" => "[network][name]" }
        rename => {"[notag][Operating System]" => "[host][os][name]" }
        rename => {"[notag][Last Logged In User]" => "[host][last_logged_in_user]" }
        rename => {"[notag][Tanium Client IP Address]" => "[source][ip]" }
        rename => {"[notag][Connection Name]" => "[event][reason]" }
        rename => {"[notag][x64/x86?]" => "[host][architecture]" }
        rename => {"[notag][Model]" => "[host][model]" }
        rename => {"[notag][SEP]" => "[service][name]" }
        rename => {"[notag][SEP Version]" => "[service][version]" }
        rename => {"[notag][MCP]" => "[observer][name]" }
        rename => {"[notag][MCP Version]" => "[observer][version]" }
        copy => {"[event][reason]" => "[event][module]"}
      }
      if [service][version] and [service][version] == "[no results]" {
        mutate {
          remove_field => [ "[service][version]" ]
        }
      }
      if [observer][version] and [observer][version] == "[no results]" {
        mutate {
          remove_field => [ "[observer][version]" ]
        }
      }
    } else {
      mutate {
        add_tag => [ "not parsed" ]
        add_field => { "[event][module]" => "not parsed" }
        copy => { "message" => "[log][original]" }
      }
    }
  }
  if [rule][name] =~ "Reputation Malicious Files.*" {
    mutate {
      rename => {"[tanm][Match Details][match][properties][fullpath]" => "[file][path]" }
    }
  }
  date {
    match => ["[event][start]" , "ISO8601" ]
    timezone => "GMT"
    locale => "en"
    target => "[event][start]"
    tag_on_failure => "_dateparsefailure_es"
  }
  date {
    match => ["[event][created]" , "ISO8601" ]
    timezone => "GMT"
    locale => "en"
    target => "[event][created]"
    tag_on_failure => "_dateparsefailure_ec"
  }
  if "_dateparsefailure_es" in [tags]  {
    if ![log][original] {
      mutate {
        copy => { "message" => "[log][original]" }
      }
    }
    mutate {
     remove_field => ["[event][start]"]
    }
  }
  date {
    match => ["[event][end]" , "ISO8601" ]
    timezone => "GMT"
    locale => "en"
    target => "[event][end]"
    tag_on_failure => "_dateparsefailure_ee"
  }
  if "_dateparsefailure_ee" in [tags]  {
    if ![log][original] {
      mutate {
        copy => { "message" => "[log][original]" }
      }
    }
    mutate {
     remove_field => ["[event][end]"]
    }
  }
   date {
    match => ["[event][ingested]" , "ISO8601" ]
    timezone => "GMT"
    locale => "ei"
    target => "[event][ingested]"
    tag_on_failure => "_dateparsefailure_ee"
  }
  if "_dateparsefailure_ei" in [tags]  {
    if ![log][original] {
      mutate {
        copy => { "message" => "[log][original]" }
      }
    }
    mutate {
     remove_field => ["[event][ingested]"]
    }
  }
  mutate {
    remove_field => [ "rest_msg", "tanm", "notag" ] # "actual_msg"
  }
  mutate {
    gsub => [ "[threat][technique][id]", '[\"\[\]]', "" ]
  }
  #   ruby {
  #     code => 'event.set("[user][domain]", event.get("[user][domain]").uniq)'
  #   }
  #   ruby {
  #     code => 'event.set("[user][name]", event.get("[user][name]").uniq)'
  #   }
  ## Remove empty lists
  if ![process][parent][hash][sha1][0] and [process][parent][hash][sha1] !~ ".*?" {
    mutate {
      remove_field => ["[process][parent][hash][sha1]"]
    }
  }
  if ![process][parent][hash][md5][0] and [process][parent][hash][md5] !~ ".*?" {
    mutate {
      remove_field => ["[process][parent][hash][md5]"]
    }
  }
  if ![process][parent][args][0] and [process][parent][args] !~ ".*?" {
    mutate {
      remove_field => ["[process][parent][args]"]
    }
  }
  if ![process][parent][executable][0] and [process][parent][executable] !~ ".*?" {
    mutate {
      remove_field => ["[process][parent][args]"]
    }
  }
  if ![process][parent][executable][0] and [process][parent][executable] !~ ".*?" {
    mutate {
      remove_field => ["[process][parent][hash][sha256]"]
    }
  }
  if ![threat][technique][id][0] and [threat][technique][id] !~ ".*?" {
    mutate {
      remove_field => ["[threat][technique][id]"]
    }
  }
  if ![threat][tactic][id][0] and [threat][tactic][id] !~ ".*?" {
    mutate {
      remove_field => ["[threat][tactic][id]"]
    }
  }
  if ![threat][technique][subtechnique][id][0] and [threat][technique][subtechnique][id] !~ ".*?" {
    mutate {
      remove_field => ["[threat][technique][subtechnique][id]"]
    }
  }
  # Do not remove this, due to internal need.
  if [host][hostname] and ([host][hostname] != "" or [host][hostname][0] != "" ){
    mutate {
      copy => { "[host][hostname]" => "[host][name]" }
    }
  }
}
output {
  pipeline { send_to => [enrichments] }
}
